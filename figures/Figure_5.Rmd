---
title: "Figure 5 & Suppl. Fig. 5"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE}
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(toscatools))
suppressPackageStartupMessages(library(data.table))
# suppressPackageStartupMessages(library(paletteer))
# suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(scales))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(mixtools))
suppressPackageStartupMessages(library(stringi))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(GenomicFeatures))
```

#### Functions

```{r}
# http://tinyheero.github.io/2015/10/13/mixture-model.html
# 
#' Plot a Mixture Component
#' 
#' @param x Input data
#' @param mu Mean of component
#' @param sigma Standard deviation of component
#' @param lam Mixture weight of component

plot_mix_comps <- function(x, mu, sigma, lam) {
  lam * dnorm(x, mu, sigma)
}

remove_rrna_trna_duplexes <- function(hybrids) {
  
  # Exclude rRNA and tRNA from duplexes
  hybrids <- hybrids[!(L_seqnames == "rRNA_45S" & R_seqnames == "rRNA_45S")]
  hybrids <- hybrids[!(L_seqnames == "rDNA" & R_seqnames == "rDNA")]
  hybrids <- hybrids[!(L_seqnames == "rRNA_5S" & R_seqnames == "rRNA_5S")]
  hybrids <- hybrids[!(L_seqnames == "rRNA5S" & R_seqnames == "rRNA5S")]
  hybrids <- hybrids[!grepl("tRNA", L_seqnames)]
  hybrids <- hybrids[!grepl("tRNA", R_seqnames)]
  
  return(hybrids)
}

get_basepairs_count <- function(forgi.df) {
  
  duplex_max.df <- forgi.df %>%
    group_by(id) %>%
    dplyr::filter(element_type == "s") %>%
    summarise(total_paired = sum(L_width)) %>%
    dplyr::select(id, total_paired)
  
  forgi.df <- left_join(forgi.df, duplex_max.df, by = "id")
  
  return(forgi.df)
}

get_unpaired_total <- function(forgi.df, group = NULL) {
  
  data_i.df <- forgi.df %>%
    group_by({{group}}, id) %>%
    dplyr::filter(element_type == "i") %>%
    replace(is.na(.), 0) %>%
    mutate(iloop_length_L = sum(L_width),
           iloop_length_R = sum(R_width)) %>%
    dplyr::select(id, {{group}}, iloop_length_L, iloop_length_R) %>%
    ungroup() %>%
    distinct() %>%
    rowwise() %>%
    mutate(total_unpaired = sum(iloop_length_L, iloop_length_R)) %>%
    #dplyr::select(-c(iloop_length_L, iloop_length_R)) %>%
    ungroup()
   #data.df <- left_join(data.df, data_i.df, by = c(str(quote(group)), "id"))
  
  return(data_i.df)
}

get_paired_metric <- function(clusters.df, group = NULL) {
  
  paired_metric.df <- clusters.df %>%
    dplyr::select({{group}}, name, total_paired, total_unpaired) %>%
    replace(is.na(.), 0) %>%
    distinct() %>%
    rowwise() %>%
    mutate(paired_to_total_ratio = total_paired*2/(total_paired*2 + total_unpaired)) %>%
    ungroup() %>%
    dplyr::select({{group}}, name, paired_to_total_ratio)
  
  return(paired_metric.df)
}

get_paired_regions <- function(id, L_db, R_db) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  l_start <- l_brackets[1]
  l_end <- l_brackets[length(l_brackets)]
  
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  r_start <- r_brackets[1]
  r_end <- r_brackets[length(r_brackets)]
  
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  results.ls <- list(id = id, l_start = l_start, l_end = l_end, 
                     r_start=r_start, r_end=r_end)
  
  return(results.ls)
  
}

trim_duplex_overhangs <- function(clusters.df) {
  
  # Separate L_db and R_db
  clusters.df <- clusters.df %>%
    separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)
  
  # Get positions of paired residues within structures of each arm
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(paired_regions = list(get_paired_regions(id, L_db, R_db))) %>%
    mutate(L_duplex_start = paired_regions$l_start, 
           L_duplex_end = paired_regions$l_end,
           R_duplex_start = paired_regions$r_start, 
           R_duplex_end = paired_regions$r_end) %>%
    ungroup() %>%
    dplyr::select(-paired_regions)
  
  # Adjust genomic coordinates to only include the paired region
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(L_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_start - 1,
                                      TRUE ~ L_genomic_end - L_duplex_end + 1),
           L_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_end - 1,
                                    TRUE ~ L_genomic_end - L_duplex_start + 1),
           R_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_start - 1,
                                      TRUE ~ R_genomic_end - R_duplex_end + 1),
           R_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_end - 1,
                                    TRUE ~ R_genomic_end - R_duplex_start + 1)) %>%
    ungroup()
  
  return(clusters.df)
}


correct_bulge_positions <- function(forgi.df) {
  # Forgi output places all asymmetric internal loops and bulges on the left side, even when they should be on the right.
  # If such cases exist, swap them to the right
  # !!!THIS FUNCTION MUST BE APPLIED ON SINGLE DUPLEX STRUCTURES
  
  stem_L.df <- forgi.df %>%
    group_by(Experiment, id) %>%
    dplyr::filter(element_type == "s") %>%
    mutate(stem_L_limit = max(L_end) ) %>%
    dplyr::select(id, Experiment, stem_L_limit) %>%
    ungroup() %>%
    distinct()

  forgi.df <- left_join(forgi.df, stem_L.df, by = c("Experiment", "id"))
  
  if (nrow(dplyr::filter(forgi.df, L_start > stem_L_limit)) == 0) {
      
    forgi.df <- forgi.df %>%
        dplyr::select(-stem_L_limit)
    
  } else {
      
    forgi.df <- forgi.df %>%
      rowwise() %>%
      mutate(swap = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~  "yes", TRUE ~ "no"),
              R_start = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_start),
                                  TRUE ~ as.double(R_start)),
              R_end = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_end),
                                 TRUE ~ as.double(R_end)),
              R_width = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_width),
                                   TRUE ~ as.double(R_width))) %>%
      ungroup()
    
    forgi.df <- forgi.df %>%
      rowwise() %>%
      mutate(L_start = case_when(swap == "yes" ~ 0, 
                                 TRUE ~ as.double(L_start)),
             L_end = case_when(swap == "yes" ~ 0,
                                   TRUE ~ as.double(L_end)),
             L_width = case_when(swap == "yes" ~ 0,
                                     TRUE ~ as.double(L_width))) %>%
          ungroup() %>%
          dplyr::select(-stem_L_limit, -swap)
    
      }
  return(forgi.df)
}

calculate_percentage <- function(data.df, column, group = NULL, simplify = FALSE) {
  
  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    #arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts))) %>%
    mutate(percentage = as.numeric(sub("%","", percentage)))
  
  if (simplify) {
    data_counts.df <- data_counts.df %>%
      mutate(category = case_when((percentage <= 2) ~ "Other",
                                  (percentage > 2) ~ as.character({{column}})))
    
    data_counts.df <- data_counts.df %>%
      group_by({{group}}, category) %>%
      mutate(percentage = sum(percentage)) %>%
      ungroup() %>%
      dplyr::select(category, percentage, {{group}}) %>%
      distinct()
  }
  
  return(data_counts.df)
  
}

get_paired_residues <- function(id, L_db, L_sequence, R_db, R_sequence) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  # paired_residues_count <- length(l_brackets)
  l_paired_residues <- paste(str_sub(L_sequence, start = l_brackets, end = l_brackets), collapse = '')
  r_paired_residues <- paste(str_sub(R_sequence, start = r_brackets, end = r_brackets), collapse = '')
  
  results.ls <- list(id = id, l_paired_residues = l_paired_residues, r_paired_residues = r_paired_residues)
  
  return(results.ls)
  
}

#' A function to find all locations of a specific residue within a sequence
#'
#' @description 
#' This function will find and locate the letter "residue" within a string sequence "x"
#' 
#' @param residue one letter you'd like to find
#' @param x the string you would like to find it in
find_residue <- function(residue, x) {
  pos <- str_locate_all(x, residue)
  return(unique(unlist(pos)))
}

get_base_pair_percentage <- function(data.df, residue1, residue2) {
  
  pair.df <- data.df %>%
    mutate_at("R_paired_residues", stri_reverse) %>%  # need to reverse seq of R arm
    rowwise() %>%
    mutate(residue1_pos_L = list(find_residue(L_paired_residues, residue = residue1)),
           residue2_pos_L = list(find_residue(L_paired_residues, residue = residue2)),
           residue1_pos_R = list(find_residue(R_paired_residues, residue = residue1)),
           residue2_pos_R = list(find_residue(R_paired_residues, residue = residue2))) %>%
    ungroup()
  
  # Obtain the positions of residues 1 and residues 2 in L and see if the same but complement in R
  pair.df <- pair.df %>%
    rowwise() %>%
    mutate(residue1residue2_pairs = list(intersect(residue1_pos_L, residue2_pos_R)),
           residue2residue1_pairs = list(intersect(residue2_pos_L, residue1_pos_R))) %>%
    mutate(pair_pos = list(union(residue1residue2_pairs, residue2residue1_pairs))) %>%
    mutate(pair_pos_count = length(pair_pos)) %>%
    mutate(pair_percentage = pair_pos_count*100/total_paired) %>%
    ungroup() %>%
    dplyr::select(id, pair_pos, pair_pos_count, pair_percentage) %>%
    distinct()
  # Add residues prefix
  residue_pair <- paste(residue1, residue2, sep = "")
  pair.df <- pair.df %>%
    dplyr::rename_at(vars(pair_pos:pair_percentage), function(x){paste0(residue_pair, "_", x)})
  
  # pair.df <- pair.df %>%
  #   dplyr::rename_at(vars(pair_pos:pair_percentage), function(x){replace(x, "pair", residue_pair)})
  
  data.df <- left_join(data.df, pair.df, by = "id") 
  
  return(data.df)
}

# Count_identical_characters in 2 vectors of same length
check_identical_characters <- function(x, y) {
  
  check = FALSE
  
  if (x == y) {
    check = TRUE
  } else {
    check = FALSE
  }

  return(check)
}

count_identical_characters <- function(a, b, sep = NA) {
  
  stopifnot(length(a) == length(b))
  
  a <- unlist(str_split(a, sep))
  b <- unlist(str_split(b, sep))
  
  stopifnot(length(a) == length(b))
  
  iterations = length(a)
  
  z <- lapply(1:iterations, function(x) check_identical_characters(a[x], b[x]))

  #return(unlist(z))
  return(sum(unlist(z))) # count booleans
  
}

```

#### Data

```{r}
ref.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/ref"
work.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions"

stau1.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/atlas"
derived.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/results_nornase"
paris.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/paris/results_paris/atlas_clusters"
ricseq.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/ricseq/results_ricseq/atlas_clusters"

plots.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/revisions/plots/figure_5"
```


# Compare hybrid read lengths between the different prox-ligation protocols

```{r}

```



```{r message=FALSE}
# Clusters (collapsed) and structure annotations

# STAU1
stau1.dt <- fread(paste0(stau1.dir, "/merged.atlas.clusters.tsv.gz"))
stau1.mfe.dt <- fread(paste0(stau1.dir, "/merged.atlas.clusters.tsv.gz"))
stau1_forgi.dt <- fread(paste0(stau1.dir, "/merged.atlas.clusters.forgi.tsv.gz"))

short_range.mfe.dt <- fread(paste0(derived.dir, "/short_range_duplexes.mfe.tsv.gz"))
short_range.forgi.dt <- fread(paste0(derived.dir, "/short_range_duplexes.forgi.tsv.gz"))

# PARIS
paris.dt <- fread(paste0(paris.dir,"/all.atlas_clusters.gc.annotated.tsv.gz"))
paris.mfe.dt <- fread(paste0(paris.dir,"/paris.atlas.clusters.utr3.mfe.tsv.gz")) # only intragenic 3'UTR
paris_forgi.dt <- fread(paste0(paris.dir,"/paris.atlas.clusters.utr3.forgi.tsv.gz"))

# RIC-seq
ricseq.dt <- fread(paste0(ricseq.dir,"/all.atlas_clusters.gc.annotated.tsv.gz"))
ricseq.mfe.dt <- fread(paste0(ricseq.dir,"/ricseq.atlas.clusters.utr3.mfe.tsv.gz")) # only intragenic 3'UTR
ricseq_forgi.dt <- fread(paste0(ricseq.dir,"/ricseq.atlas.clusters.utr3.forgi.tsv.gz"))

# Clustered hybrids
stau1.hybrids.dt <- fread(paste0(stau1.dir, "/merged.atlas.clustered.tsv.gz"))
# paris.hybrids.dt <- fread(paste0(data.dir, "/paris_atlas/all.atlas_clusters.gc.annotated.tsv.gz"))
```


Assign the sample information to the clusters

```{r}
# Rename clusters for derived duplexes
stau1.hybrids.dt <- stau1.hybrids.dt %>%
  mutate(cluster = case_when(sample == "stau1_derived" & !str_detect(cluster, "C") ~ name,
                             TRUE ~ cluster))

# Create an id column to be consistent with the name column of the collapsed clusters table
stau1.cluster.hybrids.df <- stau1.hybrids.dt %>%
  rowwise() %>%
  mutate(id = case_when(cluster == name ~ cluster, # these are the ID ones
                        TRUE ~ paste(cluster, L_seqnames, R_seqnames, sep = "-"))) %>%
  ungroup()

# Assign samples to all hybrids
stau1.cluster.hybrids_summary.df <- stau1.cluster.hybrids.df %>%
  group_by(id) %>%
  summarize(sample_set = paste(sort(unique(sample)), collapse=",")) %>%
  ungroup() 

stau1.samples.df <- stau1.cluster.hybrids_summary.df %>%
  dplyr::select(id, sample_set) %>%
  distinct()

# fwrite(stau1.cluster.hybrids_summary.df, paste0(data.dir, "/stau1.cluster.hybrids_summary.tsv.gz", sep = "\t"))
stau1.dt <- left_join(stau1.dt, dplyr::select(stau1.samples.df, id, sample_set), by = c("name" = "id"))
```

***
> STAU1 hiCLIP cluster counts

The number of STAU1 clusters is `r nrow(stau1.dt)`


```{r}
# Exclude rRNA and tRNA from duplexes
paris.dt <- remove_rrna_trna_duplexes(paris.dt)
stau1.dt <- remove_rrna_trna_duplexes(stau1.dt)
ricseq.dt <- remove_rrna_trna_duplexes(ricseq.dt)
```


```{r}
colnames(stau1.dt)
```


The number of PARIS duplexes excluding rRNA and tRNA is `r nrow(paris.dt)`
The number of STAU1 hiCLIP + short-range duplexes is `r nrow(stau1.dt)`

# Fig 5 A: Duplex locations

```{r}
stau1.dt <- stau1.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id & sample_set != "stau1_derived" ~ "Intra-transcript",
                          sample_set == "stau1_derived" & L_seqnames == R_seqnames ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))

intra_stau1.dt <- stau1.dt %>%
  dplyr::filter(type == "Intra-transcript")
```

There are `r nrow(intra_stau1.dt)` intramolecular duplexes within STAU1 hiCLIP duplex atlas.

***
> STAU1 locations

```{r warning=FALSE}
# Filter out intronic regions 
intra_stau1.dt <- intra_stau1.dt %>%
  dplyr::filter(L_region != "intron" & R_region != "intron")
```

The are `r nrow(intra_stau1.dt)` intra-transcript STAU1 duplexes, excluding introns. 

```{r warning=FALSE}
stau1_duplex_regions.df <- intra_stau1.dt %>%
  dplyr::filter(!str_detect(cluster, "ID")) %>% # exclude predicted duplexes 
  rowwise() %>%
  mutate(region_pairs = paste(sort(c(L_region, R_region)), collapse = " - ")) %>%
  ungroup()
```

***
> PARIS locations

```{r}
paris.dt <- paris.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))
intra_paris.dt <- paris.dt %>%
  dplyr::filter(type == "Intra-transcript")

# Filter out intronic regions 
intra_paris.dt <- intra_paris.dt %>%
  dplyr::filter(L_region != "intron" & R_region != "intron")

intra_paris_duplex_regions.df <- intra_paris.dt %>%
  rowwise() %>%
  mutate(region_pairs = paste(sort(c(L_region, R_region)), collapse = " - ")) %>%
  ungroup()
```

The are `r nrow(intra_paris.dt)` intra-transcript PARIS duplexes, excluding introns. 

***
> RIC-seq locations

```{r}
ricseq.dt <- ricseq.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))
intra_ricseq.dt <- ricseq.dt %>%
  dplyr::filter(type == "Intra-transcript")

# Filter out intronic regions 
intra_ricseq.dt <- intra_ricseq.dt %>%
  dplyr::filter(L_region != "intron" & R_region != "intron")

intra_ricseq_duplex_regions.df <- intra_ricseq.dt %>%
  rowwise() %>%
  mutate(region_pairs = paste(sort(c(L_region, R_region)), collapse = " - ")) %>%
  ungroup()
```

The are `r nrow(intra_ricseq.dt)` intra-transcript PARIS duplexes, excluding introns. 

```{r}
stau1_duplex_regions.df$Experiment <- "STAU1"
intra_paris_duplex_regions.df$Experiment <- "PARIS"
intra_ricseq_duplex_regions.df$Experiment <- "RIC-seq"

regions.df <- bind_rows(stau1_duplex_regions.df, intra_paris_duplex_regions.df, intra_ricseq_duplex_regions.df)
regions.df <- regions.df %>%
  mutate(id = paste(Experiment, name, sep = "_"))

regions.df$Experiment <- factor(regions.df$Experiment, levels = c("RIC-seq", "PARIS", "STAU1"))

regions_percentage.df <- calculate_percentage(regions.df, column = region_pairs, group = Experiment, simplify = TRUE)
regions_percentage.df$category <- factor(regions_percentage.df$category, 
                                  levels = c("UTR5 - UTR5","CDS - UTR5", "CDS - CDS","CDS - UTR3", "UTR3 - UTR3",
                                             "ncRNA - ncRNA", "Other"))

interregion_colours <- c("CDS - CDS" = "#638b66", "CDS - ncRNA" = "#B03A2E", "CDS - UTR3" = "#A9CCE3",
                    "CDS - UTR5" = "#C39BD3", "ncRNA - ncRNA" = "#fbb04e", "Other" = "#AAB7B8",
                    "UTR3 - UTR3" = "#f47942", "UTR5 - UTR5" = "#a2ceaa")

regions.gg <- ggplot(regions_percentage.df, aes(x = Experiment, y = percentage, fill = category, group = category)) +
  geom_bar(stat = "identity", width = 0.5) +
  geom_text(aes(label=ifelse(percentage >= 5, paste0(round(percentage, 1),"%"),"")),
                position=position_stack(vjust=0.5), colour="white") +
  coord_flip() +
  scale_fill_manual(values = interregion_colours) +
  theme_minimal_grid() + theme(legend.position = "bottom") +
  labs(x = "",
       y = "Percentage of intra-transcript duplexes",
       fill = "") +
  scale_y_reverse()
regions.gg

ggsave(paste0(plots.dir, "/arm_region_pairs.pdf"), regions.gg, width = 7, height = 5, dpi = 300)
```

> Filter intra-transcript 3'UTR duplexes from both datasets

To get more comparable datasets, we focused on the 3'UTR intra-transcript duplexes for all datasets. 

```{r}
# Annotate predicted struc with UTR3 as regions
intra_stau1.dt <- intra_stau1.dt %>% 
  mutate(L_region = case_when(sample_set == "stau1_derived" ~ "UTR3",
                              TRUE ~ L_region), 
         R_region = case_when(sample_set == "stau1_derived" ~ "UTR3",
                              TRUE ~ R_region))

stau1.utr3.df <- intra_stau1.dt %>%
  dplyr::filter(L_region == "UTR3" & R_region == "UTR3") %>%
  mutate(Experiment = "STAU1")

nrow(stau1.utr3.df)
nrow(stau1.utr3.df %>% dplyr::filter(sample_set == "stau1_derived"))

paris.mfe.dt <- paris.mfe.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))

paris.utr3.df <- paris.mfe.dt %>%
  dplyr::filter(L_gene_id == R_gene_id & L_region == "UTR3" & R_region == "UTR3") %>%
  mutate(Experiment = "PARIS", sample_set = "PARIS")


ricseq.mfe.dt <- ricseq.mfe.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))

ricseq.utr3.df <- ricseq.mfe.dt %>%
  dplyr::filter(L_gene_id == R_gene_id & L_region == "UTR3" & R_region == "UTR3") %>%
  mutate(Experiment = "ricseq", sample_set = "RIC-seq")

# Filter structure annotation files for the 3'UTR-3'UTR intra-transcript clusters
utr3_stau1_forgi.df <- semi_join(stau1_forgi.dt, stau1.utr3.df, by = c("id" = "name"))
utr3_stau1_forgi.df$Experiment <- "STAU1"
utr3_paris_forgi.df <- semi_join(paris_forgi.dt, paris.utr3.df, by = c("id" = "name"))
utr3_paris_forgi.df$Experiment <- "PARIS"
utr3_ricseq_forgi.df <- semi_join(ricseq_forgi.dt, ricseq.utr3.df, by = c("id" = "name"))
utr3_ricseq_forgi.df$Experiment <- "RIC-seq"

# Append datasets
utr3_clusters.df <- rbind(stau1.utr3.df, paris.utr3.df, ricseq.utr3.df)
```


Clusters remaining in the STAU1 data: `{r} nrow(stau1.utr3.df)`
Clusters remaining in the PARIS data: `{r} nrow(paris.utr3.df)`
Clusters remaining in the RIC-seq data: `{r} nrow(ricseq.utr3.df)`

Need to adjust the genomic and transcriptomic coordinates to focus on the stem of the structure (for clustered duplexes only because for the short-range duplexes already done for Fig 3)

```{r}
# Classify structures based on detection type i.e. predicted vs experimentally detected
utr3_clusters.df <- utr3_clusters.df %>%
  mutate(detection_type = case_when(sample_set == "stau1_derived" ~ "Derived",
                                    TRUE ~ "Proximity ligation"))

# only proximity ligation hybrids
exp.utr3.df <- utr3_clusters.df %>%
  dplyr::filter(detection_type == "Proximity ligation")

nrow(dplyr::filter(exp.utr3.df, Experiment == "STAU1"))
```

There are `r nrow(exp.utr3.df)` experimentally determined duplexes within the STAU1 atlas

```{r}
predicted_stau1.utr3.df <- utr3_clusters.df %>%
  dplyr::filter(detection_type == "Derived")

exp.utr3.df <- trim_duplex_overhangs(exp.utr3.df)

predicted_stau1.utr3.df <- predicted_stau1.utr3.df %>%
  mutate(L_genomic_duplex_start = L_genomic_start,
         R_genomic_duplex_start = R_genomic_start,
         L_genomic_duplex_end = L_genomic_end,
         R_genomic_duplex_end = R_genomic_end)

stopifnot(nrow(utr3_clusters.df) == nrow(rbind(data.table(exp.utr3.df), data.table(predicted_stau1.utr3.df), fill = TRUE)))

utr3_clusters.df <- rbind(data.table(exp.utr3.df), data.table(predicted_stau1.utr3.df), fill = TRUE)
```

# Fig 5 B: Overlap with PARIS for 3'UTR intra-transcript duplexes

Comparison with PARIS HEK293 (Lu et al. 2016)

```{r}
exp_stau1.utr3.df <- dplyr::filter(exp.utr3.df, Experiment == "STAU1")
stau1.utr3.dt <- data.table(exp_stau1.utr3.df)
paris.utr3.dt <- data.table(paris.utr3.df)

stau1.utr3.dt <- reorient_hybrids(stau1.utr3.dt)
paris.utr3.dt <- reorient_hybrids(paris.utr3.dt)

bedpe.colnames <- c("L_seqnames", "L_start", "L_end", "R_seqnames", "R_start", "R_end", "name", "count", "L_strand", "R_strand")
stau1.utr3.bedpe.dt <- stau1.utr3.dt[, ..bedpe.colnames]
stau1.utr3.bedpe.dt[, `:=`(
  L_start = L_start - 1,
  R_start = R_start - 1
)]

paris.utr3.bedpe.dt <- paris.utr3.dt[, ..bedpe.colnames]
paris.utr3.bedpe.dt[, `:=`(
  L_start = L_start - 1,
  R_start = R_start - 1
)]

stau1.bedpe <- tempfile(tmpdir = getwd(), fileext = ".bedpe")
paris.bedpe <- tempfile(tmpdir = getwd(), fileext = ".bedpe")

ol <- tempfile(tmpdir = getwd(), fileext = ".bedpe")

fwrite(stau1.utr3.bedpe.dt, file = stau1.bedpe, sep = "\t", col.names = FALSE)
fwrite(paris.utr3.bedpe.dt, file = paris.bedpe, sep = "\t", col.names = FALSE)
cmd <- paste("bedtools pairtopair -rdn -a", stau1.bedpe, "-b", paris.bedpe, ">", ol)
system(cmd)

bedpe.dt <- fread(ol, col.names = c(paste0(bedpe.colnames, ".x"), paste0(bedpe.colnames, ".y")))
file.remove(stau1.bedpe)
file.remove(paris.bedpe)
file.remove(ol)

upset.input <- c("STAU1" = nrow(stau1.utr3.dt) - nrow(bedpe.dt),
               "PARIS" = nrow(paris.utr3.dt) - nrow(bedpe.dt),
               "STAU1&PARIS" = nrow(bedpe.dt))

pdf(file.path(plots.dir, "stau1_paris_utr3_upset.pdf"), width = 7, height = 5)
UpSetR::upset(fromExpression(upset.input), 
      order.by = "freq",
      mainbar.y.label = "Intersecting number of duplexes",
      sets.x.label = "Total number of duplexes")
dev.off()
```

# Fig 5 C: Hybrid spans

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(duplex_span = case_when(L_genomic_strand == "+" ~ R_genomic_duplex_start - L_genomic_duplex_end + 1 - 2,
                                  L_genomic_strand == "-" ~ L_genomic_duplex_start - R_genomic_duplex_end + 1 - 2)) %>%
  ungroup()

span_median <- utr3_clusters.df %>%
    group_by(Experiment, detection_type) %>%
    dplyr::summarize(Median = median(duplex_span, na.rm=TRUE))
span_median

span_mean <- utr3_clusters.df %>%
    group_by(Experiment, detection_type) %>%
    dplyr::summarize(Mean = mean(duplex_span, na.rm=TRUE))
span_mean
```


```{r}
unique(utr3_clusters.df$Experiment)
```


```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  mutate(Experiment = str_replace(Experiment, "ricseq", "RIC-seq"))
```

Define span groups:

```{r}
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))
utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::mutate(span_group = case_when(sample_set == "stau1_derived" ~ "derived short range",
                                       !sample_set == "stau1_derived" & duplex_span <= 100 & duplex_span >= 25 ~ "medium range",
                                       !sample_set == "stau1_derived" & duplex_span < 25 ~ "short range",
                                       !sample_set == "stau1_derived" & duplex_span > 100 ~ "long range"))

```

# Suppl. Fig 5 A

We can fit a 2-component Gaussian mixture model to the bimodal STAU1 distribution

```{r}
# Extract data for gauss mixture model

set.seed(42)
mixmdl <- normalmixEM(log10(utr3_clusters.df[utr3_clusters.df$Experiment == "STAU1" & utr3_clusters.df$detection_type == "Proximity ligation" & utr3_clusters.df$duplex_span > 0 ,]$duplex_span), k = 2)

mix.gg <- ggplot() +
  geom_histogram(data = data.frame(x = mixmdl$x), aes(x, ..density..), bins = 100, fill = "grey75") +
  stat_function(data = data.frame(x = mixmdl$x), geom = "line", fun = plot_mix_comps,
                args = list(mixmdl$mu[1], mixmdl$sigma[1], lam = mixmdl$lambda[1]),
                colour = "red", lwd = 1.5) +
  stat_function(data = data.frame(x = mixmdl$x), geom = "line", fun = plot_mix_comps,
                args = list(mixmdl$mu[2], mixmdl$sigma[2], lam = mixmdl$lambda[2]),
                colour = "blue", lwd = 1.5) +
  scale_x_continuous(labels = c(1, 10, 100, 1000, 10000)) +
  labs(x = "Duplex span (nt)",
       y = "Density") +
  theme_minimal_grid()

mix.gg

ggsave(paste0(plots.dir, "/duplex_span_gauss_mixture.pdf"), mix.gg, dpi = 300, width = 4, height = 4)
```
This gives us two distributions with mean duplex spans of `r round(10^mixmdl$mu, 3)[1]` and `r round(10^mixmdl$mu, 3)[2]` and lambdas of `r round(mixmdl$lambda, 3)[1]` and `r round(mixmdl$lambda, 3)[2]` respectively.

```{r}
round(10^mixmdl$mu, 3)[1]

round(10^mixmdl$mu, 3)[2]

round(mixmdl$lambda, 3)[1]

round(mixmdl$lambda, 3)[2]
```


```{r}
span_median <- span_median %>%
  mutate(Median = case_when(Experiment == "STAU1" & detection_type == "Proximity ligation" ~ round(10^mixmdl$mu, 3)[1],
                   TRUE ~ Median))
span_median2 <- span_median %>%
  dplyr::filter(Experiment == "STAU1" & detection_type == "Proximity ligation") %>%
  mutate(Median = round(10^mixmdl$mu, 3)[2])

span_median <- rbind(span_median, span_median2)

utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::mutate(condition = case_when(detection_type == "Derived" ~ "Derived",
                                      TRUE ~ as.character(Experiment)))

condition_colours <- c("Derived" = "#2fa1b2", "PARIS" = "#f28e2d", "STAU1" = "#507aa8", "RIC-seq" = "#7851a9")
utr3_clusters.df$condition <- factor(utr3_clusters.df$condition, levels = c("STAU1", "PARIS","RIC-seq", "Derived"))

duplex_span.gg <- ggplot(utr3_clusters.df, aes(x = duplex_span, color = condition, group = condition)) + 
  geom_density(bw = 0.1) +
  scale_linetype_manual(values=c("dotted", "solid")) +
  scale_x_log10() + annotation_logticks(sides = "b") +
  scale_color_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "right") +
  ylab("Density") +
  xlab("Duplex span (nt) ") +
  geom_vline(data=span_median, aes(xintercept=Median, color=Experiment),
             linetype="dotted") +
  facet_grid(rows = vars(factor(detection_type, levels = c("Proximity ligation", "Derived"))), scales = "free_y")

duplex_span.gg
ggsave(paste0(plots.dir, "/duplex_span.pdf"), duplex_span.gg, dpi = 300, width = 6.5, height = 4)
```

# Fig 5 G: Stem lengths

Compare the number of paired residues within each duplex

```{r}
# Get base-pairs count
utr3_stau1_forgi.df <- get_basepairs_count(utr3_stau1_forgi.df)
utr3_paris_forgi.df <- get_basepairs_count(utr3_paris_forgi.df)
utr3_ricseq_forgi.df <- get_basepairs_count(utr3_ricseq_forgi.df)

utr3_forgi.df <- rbind(utr3_stau1_forgi.df, utr3_paris_forgi.df, utr3_ricseq_forgi.df)

utr3_bp.df <- utr3_forgi.df %>%
  distinct(Experiment, id, total_paired)

utr3_clusters.df <- left_join(utr3_clusters.df, utr3_bp.df, by = c("Experiment", c("name" = "id")))
```

```{r}
span_counts <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(counts = n()) 

utr3_clusters.df$span_group <- factor(utr3_clusters.df$span_group, levels = c("long range", "medium range", "short range", "derived short range"))
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))

total_paired.gg <- ggplot(utr3_clusters.df,
                         aes(x = Experiment, y=total_paired, fill=condition)) +
  geom_boxplot(outlier.shape = NA, width = 0.5) +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Base-pairs per duplex (bp)") +
  ylim(-1.5, 40) +
  facet_grid(cols = vars(factor(span_group, levels=c("long range", "medium range", "short range", "derived short range")))) +
  geom_label(data = span_counts, aes(label=counts, y = -1.5), label.padding = unit(0.25, "lines"),
            position=position_dodge(width=1.0), inherit.aes = TRUE,  fill = "white", size = 3)
total_paired.gg 
ggsave(paste0(plots.dir, "/total_paired.pdf"), total_paired.gg, dpi = 300, width = 5, height = 6)
```

```{r}
# Wilcox.test
stau1.bp.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$total_paired
paris.bp.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS" & !str_detect(cluster, "ID"))$total_paired

median(stau1.bp.ls)
median(paris.bp.ls)
mean(stau1.bp.ls)
mean(paris.bp.ls)

wilcox.test(stau1.bp.ls, paris.bp.ls, alternative = "two.sided")
```


# Fig 5 D: Hybridisation energy

```{r}
# Filter out duplexes with no duplex binding energy
utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::filter((!str_detect(L_sequence, "N"))) %>%
  dplyr::filter((!str_detect(R_sequence, "N")))

# Normalise MFE scores to number of paired res
utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(normalised_mfe = mfe/total_paired,
         normalised_mean_shuffled_mfe = mean_shuffled_mfe/total_paired,
         normalised_sd_shuffled_mfe = sd_shuffled_mfe/total_paired) %>%
  ungroup()
```


```{r}
# Test significance
# stau1.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$mfe
stau1.norm_mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$normalised_mfe
stau1.shuffled.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$normalised_mean_shuffled_mfe
# paris.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$mfe
paris.norm_mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$normalised_mfe
paris.shuffled.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$normalised_mean_shuffled_mfe

# Differences vs shuffled
wilcox.test(stau1.norm_mfe.ls, stau1.shuffled.mfe.ls) # STAU1
wilcox.test(paris.norm_mfe.ls, paris.shuffled.mfe.ls) # PARIS
# Absolute mfe difference vs PARIS
# mean(stau1.mfe.ls) - mean(paris.mfe.ls)
# MFE per bp difference
mean(stau1.norm_mfe.ls) - mean(paris.norm_mfe.ls)
```


Wilxox test p value for the MFE/bp difference is: `r wilcox.test(stau1.norm_mfe.ls, paris.norm_mfe.ls)$p.val`

```{r}
# STAU vs PARIS
wilcox.test(stau1.norm_mfe.ls, paris.norm_mfe.ls)$p.val
```


The MFE/bp median is: 

```{r}
mfe_median <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(normalised_mfe, na.rm = TRUE))
mfe_median

utr3_clusters_mfe.df <- pivot_longer(utr3_clusters.df, cols = c(normalised_mfe, normalised_mean_shuffled_mfe), names_to = "Sample", values_to = "MFE")

utr3_clusters_mfe.df <- utr3_clusters_mfe.df %>%
  mutate(Sample = case_when((Sample == "normalised_mfe") ~ "STAU1",
                            (Sample == "normalised_mean_shuffled_mfe") ~ "Shuffled control"))


mfe.dens.gg <- ggplot(utr3_clusters_mfe.df, aes(x = MFE, linetype = Sample, color = condition)) + 
  geom_density(alpha = 0.8) +
  #annotate("text", label = "p < 2.2e-16", x = -1, y = 1.7) +
  scale_linetype_manual(values=c("longdash", "solid")) +
  scale_color_manual(values = condition_colours) +
  theme_minimal_grid() + 
  facet_grid(rows = vars(Experiment), cols = vars(span_group)) +
  theme(legend.position = "top") +
  ylab("Density") +
  xlab("Normalised hybridisation energy (kcal/mol)/bp") +
  geom_vline(data=mfe_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  xlim(-2.5, 0)

mfe.dens.gg
ggsave(paste0(plots.dir, "/hybridisation_energy.pdf"), mfe.dens.gg, dpi = 300, width = 5.2, height = 4)

```

# Fig 5 F: Proportion of paired residues

The *paired metric* is a measure that takes into account the ratio of paired residues to non-paired residues (bulges and internal loops) in each duplex. The formula is:

$$
\text{Paired Metric} = \frac{(n_p)*2}{(n_p)*2 + (L_u + R_u)}, \\
\text{ } \\
\text{where:} \\
 n_p = \text{number of paired residues} \\
 L_u = \text{number of unpaired residues left arm} \\
 R_u = \text{number of unpaired residues right arm}
$$

Correct internal loop and bulges positions:

```{r}
utr3_forgi.df <- correct_bulge_positions(utr3_forgi.df)
```

Calculate the percentage of paired residues: 

```{r}
# Calculate paired metric
unpaired.df <- get_unpaired_total(utr3_forgi.df, group = Experiment)
utr3_clusters.df <- left_join(utr3_clusters.df, unpaired.df, by = c("Experiment", c("name" = "id")))

paired_metric.df <- get_paired_metric(utr3_clusters.df, group = Experiment)
utr3_clusters.df <- left_join(utr3_clusters.df, paired_metric.df, by = c("Experiment", "name"))

# Convert to percentage
utr3_clusters.df <- utr3_clusters.df %>%
  ungroup() %>%
  mutate(paired_percentage = paired_to_total_ratio*100) %>%
  dplyr::select(-paired_to_total_ratio)

```

```{r}
paired_percentage_median <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(paired_percentage, na.rm = TRUE))
paired_percentage_median

utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))

paired_metric.gg <- ggplot(utr3_clusters.df, aes(x=paired_percentage, color = condition)) + 
  geom_density() +
  scale_color_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "right") +
  ylab("Density") +
  xlab("Paired residues (%)") +
  #ggtitle("3'UTR-3'UTR clusters paired metric") +
  geom_vline(data=paired_percentage_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  facet_grid(rows = vars(span_group))
  #annotate("text", label = paste0("p = ", paired_ratio.pval), x = 80, y = 0.07)

paired_metric.gg

ggsave(paste0(plots.dir, "/paired_metric.pdf"), paired_metric.gg, dpi = 300, width = 5, height = 4)
```


```{r}
stau1.paired_ratio.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1"  & !str_detect(cluster, "ID"))$paired_percentage
paris.paired_ratio.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$paired_percentage

paired_ratio.pval <- wilcox.test(stau1.paired_ratio.ls, paris.paired_ratio.mfe.ls)$p.value
paired_ratio.pval
```

```{r}
paired_percentage_median <- utr3_clusters.df %>%
    group_by(Experiment) %>%
    dplyr::summarize(Median = median(paired_percentage, na.rm = TRUE))
paired_percentage_median
```

# Suupl. Fig 5 B: Number of bulges

```{r}
bulges.df <- utr3_forgi.df %>%
  group_by(Experiment, id) %>%
  dplyr::filter(element_type == "i") %>%
  dplyr::count(element_type) %>%
  dplyr::select(Experiment, id, n) %>%
  ungroup() %>%
  distinct() %>%
  dplyr::rename(bulge_count = n)

utr3_clusters.df <- left_join(utr3_clusters.df, bulges.df, by = c("Experiment", c("name" = "id")))
utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::select(-L_db, -R_db)

utr3_clusters.df <- utr3_clusters.df %>%
    replace(is.na(.), 0)

# Wilcox.test
stau1.bulge.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1")$bulge_count
paris.bulge.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$bulge_count
ricseq.bulge.ls <- dplyr::filter(utr3_clusters.df, Experiment == "RIC-seq")$bulge_count


median(stau1.bulge.ls)
median(paris.bulge.ls)
mean(stau1.bulge.ls)
mean(paris.bulge.ls)
median(ricseq.bulge.ls)
mean(ricseq.bulge.ls)
# wilcox.test(stau1.bulge.ls, paris.bulge.ls, alternative = "two.sided")
```



```{r message=FALSE}
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))

bulges.gg <- ggplot(utr3_clusters.df,
                         aes(x = Experiment, y=bulge_count, fill=condition)) +
  geom_boxplot(width = 0.5) +
  scale_fill_brewer(palette="Blues") +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  #ggtitle("Bulges per duplex") +
  ylab("Bulges per duplex") +
  ylim(-1.5, 16) +
  facet_grid(cols = vars(factor(span_group, levels = c("long range", "medium range", "short range", "derived short range")))) +
   geom_label(data = span_counts, aes(label=counts, y = -1.5), label.padding = unit(0.25, "lines"),
            position=position_dodge(width=1.0), inherit.aes = TRUE,  fill = "white", size = 3)
bulges.gg
ggsave(paste0(plots.dir, "/bulge_count.pdf"), bulges.gg, dpi = 300, width = 5, height = 6)
```

# Fig 5 H: Symmetry classification


The *symmetry classification* takes into account the relative position and numbers of bulges and internal loops in each predicted stem-loop structure


Proportion of perfect duplexes:

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(stem_type = case_when(paired_percentage == 100 ~ "Perfect duplex",
                               TRUE ~ "Interrupted stem")) %>%
  ungroup()
```

Explained symmetry classification:

Description | Label
------------- | -------------
Uninterrupted (no bulges or internal loops on either side) | Perfect duplex
Symmetrical (vertical axis, left-right mirror image) | Symmetric
Balanced (equal number of internal loops of identical sizes on either side, but not all of same size are opposite each other) | Asymmetric
Non-Symmetrical | Asymmetric

Obtain stem symmetry types:

```{r warning=FALSE}
# Get the complete set of internal loop widths for L and R arm 
utr3_forgi.df <- utr3_forgi.df %>%
    replace(is.na(.), 0) 

test <- utr3_forgi.df %>%
  dplyr::group_by(Experiment, id) %>%
  dplyr::filter(element_type == "i") %>%
  summarize(L_i_widths_sorted = paste(sort((L_width)),collapse=","),
            R_i_widths_sorted = paste(sort((R_width)),collapse=","),
            L_i_widths = paste((L_width),collapse=","),
            R_i_widths = paste((R_width),collapse=",")) %>%
  ungroup()


utr3_clusters.df <- left_join(utr3_clusters.df, test, by = c("Experiment", c("name" = "id")))

symmetry.df <- utr3_clusters.df %>%
  mutate(symmetry_type = case_when(stem_type == "Interrupted stem" & L_i_widths == R_i_widths ~ "Symmetric",
                                   stem_type == "Interrupted stem" & L_i_widths != R_i_widths ~ "Asymmetric",
                                   stem_type == "Perfect duplex" ~ "Perfect duplex")) %>%
  ungroup()

unique(symmetry.df$symmetry_type)
stopifnot(nrow(dplyr::filter(symmetry.df, is.na(symmetry_type))) == 0)
```

```{r}
symmetry_counts.df <- symmetry.df %>%
    dplyr::select(name, Experiment, span_group, symmetry_type) %>%
    distinct() %>%
    group_by(Experiment, span_group, symmetry_type) %>%
    summarise(counts = n()) %>%
    arrange(desc(symmetry_type)) %>%
    mutate(percentage = scales::percent(counts / sum(counts), accuracy = 0.01)) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    ungroup() %>%
    group_by(Experiment, span_group) %>%
    mutate(pos = cumsum(percentage) - percentage/2)


stem_colours <- c("Asymmetric" = "#ece2f0", "Symmetric" = "#965773", "Perfect duplex" = "#a6bddb")

symmetry_bar.gg = ggplot() + 
    geom_bar(aes(y = percentage, x = "", fill = symmetry_type), data = symmetry_counts.df,
                            stat="identity", width = 0.5) + # color="black"
    ggrepel::geom_text_repel(data = symmetry_counts.df, aes(x = "", y = pos, label=paste0(round(percentage, 1),"%")), size = 3, nudge_x = 0.4,segment.size = 0.5, segment.color = '#515A5A') + # label=paste0(round(percentage, 2),"%"))
    facet_grid(cols = vars(span_group), rows = vars(factor(Experiment, levels = c("STAU1", "PARIS", "RIC-seq")))) +
    #facet_wrap(. ~ Experiment, scales = "free") +
    scale_fill_manual(values = stem_colours) +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal_grid()

symmetry_bar.gg
ggsave(paste0(plots.dir, "/symmetry.pdf"), symmetry_bar.gg, dpi = 300, width = 7, height = 6)

```

# Fig 5 E: Base-pair composition: AU bp content

```{r}
symmetry.df <- symmetry.df %>%
  mutate(id = paste(Experiment, name, sep = "-")) %>%
    separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)

paired_res.df <- symmetry.df %>%
  rowwise() %>%
  mutate(paired_res = list(get_paired_residues(id, L_db, L_sequence, R_db, R_sequence))) %>%
  mutate(L_paired_residues = paired_res$l_paired_residues,
         R_paired_residues = paired_res$r_paired_residues) %>%
  ungroup() %>%
  dplyr::select(-paired_res)

paired_res.df <- get_base_pair_percentage(paired_res.df, "A","T")

au_median <- paired_res.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(AT_pair_percentage, na.rm = TRUE))
au_median

au_pairs.gg <- ggplot(paired_res.df, aes(x = AT_pair_percentage, color = condition)) + 
  geom_density(alpha = 0.8, adjust = 1.5) +
  #scale_x_log10() + annotation_logticks() +
  scale_color_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "right") +
  ylab("Density") +
  xlab("A:U and U:A pairs (%) ") +
  geom_vline(data=au_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  facet_grid(rows = vars(span_group))

au_pairs.gg
ggsave(paste0(plots.dir, "/au_pairs.pdf"), au_pairs.gg, dpi = 300, width = 4, height = 4)
```




```{r}
# Test overall difference
# Wilcox.test
stau1.au.ls <- dplyr::filter(paired_res.df, Experiment == "STAU1")$AT_pair_percentage
paris.au.ls <- dplyr::filter(paired_res.df, Experiment == "PARIS")$AT_pair_percentage


wilcox.test(stau1.au.ls, paris.au.ls, alternative = "two.sided")

# Test difference for long-range duplexes
lr.stau1.au.ls <- dplyr::filter(paired_res.df, Experiment == "STAU1" & span_group == "long range")$AT_pair_percentage
lr.paris.au.ls <- dplyr::filter(paired_res.df, Experiment == "PARIS"& span_group == "long range")$AT_pair_percentage

# Test overall difference
median(lr.stau1.au.ls)
median(lr.paris.au.ls)

wilcox.test(lr.stau1.au.ls, lr.paris.au.ls, alternative = "two.sided")$p.value

```


# Suppl. Fig 5 D: Asymetric stems characterisation

```{r}
asym.df <- symmetry.df %>%
  dplyr::filter(symmetry_type == "Asymmetric")

asym_forgi.df <- semi_join(utr3_forgi.df, asym.df, by = c("Experiment", c("id" = "name")))
asym_max_stem.df <- asym_forgi.df %>%
  group_by(Experiment, id) %>%
  dplyr::filter(element_type == "s") %>%
  mutate(max_paired = max(L_width)) %>%
  dplyr::select(Experiment,id, max_paired) %>%
  distinct()
asym.df <- left_join(asym.df, asym_max_stem.df, by = c("Experiment", c("name" = "id")))

# Boxplot
asym.df$Experiment <- factor(asym.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))

max_stem.gg <- ggplot(asym.df,
                         aes(x = Experiment, y=max_paired, fill=condition)) +
  geom_boxplot(width = 0.5) +
  scale_fill_brewer(palette="Blues") +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Longest bulge-free double-stranded\nsegment per duplex") +
  ylim(-1.5, 16) +
  facet_grid(cols = vars(factor(span_group, levels = c("long range", "medium range", "short range", "derived short range"))))
max_stem.gg
ggsave(paste0(plots.dir, "/maximal_stem_segment.pdf"), max_stem.gg, dpi = 300, width = 5, height = 6)

```

# Suppl. Fig 5 C

```{r}
asym_2.df <- paired_res.df %>%
  dplyr::filter(symmetry_type == "Asymmetric") %>%
  rowwise() %>%
  mutate(symmetric_bulge_count = count_identical_characters(L_i_widths, R_i_widths, sep = ",")) %>%
  mutate(symmetric_bulge_percentage = symmetric_bulge_count*100/bulge_count) %>%
  ungroup()

asym_median <- asym_2.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(symmetric_bulge_percentage, na.rm = TRUE))
asym_median

asym_2.df$Experiment <- factor(asym_2.df$Experiment, levels = c("STAU1", "PARIS", "RIC-seq"))
sym_stem.gg <- ggplot(asym_2.df,
                         aes(x = Experiment, y=symmetric_bulge_percentage, fill=condition)) +
  geom_boxplot(width = 0.5) +
  scale_fill_brewer(palette="Blues") +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_manual(values = condition_colours) +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Symmetric bulge percentage\nin asymmetric duplexes") +
  facet_grid(cols = vars(factor(span_group, levels = c("long range", "medium range", "short range", "derived short range"))))

ggsave(paste0(plots.dir, "/percentage_symmetrical_bulges.pdf"), sym_stem.gg, dpi = 300, width = 5, height = 6)
```

```{r}
fwrite(paired_res.df, paste0(plots.dir, "/all_duplex_info.tsv.gz"), sep = "\t")
fwrite(dplyr::filter(paired_res.df, Experiment == "STAU1"), paste0(plots.dir, "/stau1_duplex_info.tsv.gz"), sep = "\t")
```

# Fig 5 I: Duplex examples

Duplexes in SRSF1 3' UTR were selected, the structures were drawn using the RNA duplexdot bracket dtructures and forna

```{r}
dplyr::filter(paired_res.df, L_gene_name == "SRSF1")$Experiment
```


```{r}
example.df <- dplyr::filter(paired_res.df, Experiment == "STAU1" & symmetry_type == "Symmetric" & AU_percentage > 60 & span_group == "long range") 
dplyr::filter(example.df, L_gene_name == "SRSF1")
```

STAU1 hiCLIP example
SRSF1
C003-AC015813.1_AC015813.2_SRSF1:ENSG00000136450.13_ENSG00000264112.1_ENSG00000266086.3-AC015813.1_AC015813.2_SRSF1:ENSG00000136450.13_ENSG00000264112.1_ENSG00000266086.3	
ATTGGCAGTATTGACCTTATACTAA&ATAGAGTATAATATCAATACTGCTA
..((((((((((((..(((((((...&....)))))))..))))))))))))


```{r}
example_paris.df <- dplyr::filter(paired_res.df, Experiment == "PARIS" & AU_percentage < 60) 
dplyr::filter(example_paris.df, L_gene_name == "SRSF1")
```

PARIS hiCLIP example
SRSF1
C019-AC015813.1_AC015813.2_SRSF1:ENSG00000136450.13_ENSG00000264112.1_ENSG00000266086.3-AC015813.1_AC015813.2_SRSF1:ENSG00000136450.13_ENSG00000264112.1_ENSG00000266086.3	

GAGTCTCGCTCTGTTCTCCAGACTGGAGG&TCACTGCAACCTCCACCCCTGGATTTGAGTGATTCT
.((..((((((.....(((((..((((((&.........))))))...)))))...))))))..))


```{r}
installed.packages()[names(sessionInfo()$otherPkgs), "Version"]
```

