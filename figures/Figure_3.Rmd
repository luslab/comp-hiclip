---
title: "Figure 3 & Suppl. Fig. 3"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(rematch))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(broom))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(toscatools))
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(gginnards))
suppressPackageStartupMessages(library(factoextra))
suppressPackageStartupMessages(library(BSgenome.Hsapiens.UCSC.hg38))
```

#### Functions: metaprofiles and clustering

```{r}
convert_probability <- function(x, na.rm = FALSE) (1 - x)

get_sem <- function(x) sd(x)/sqrt(length(x))

get_metaprofile_mean <- function(filename) {
  
  prob.df <- read.csv(filename, sep="\t")
  prob.df <- column_to_rownames(prob.df, var = "X")
  colnames(prob.df) <- seq(1:ncol(prob.df)) - (ncol(prob.df)+1)/2
  prob.df <- drop_na(prob.df, 0) # remove peaks sites with NAs at the xl site

  # Convert unpaired probability to paired probability
  prob.df <- prob.df %>%
  mutate_if(is.numeric, convert_probability)

  prob.mean <- prob.df %>% 
    summarise(across(where(is.numeric), mean))
  prob.sd <- prob.df %>% 
    summarise(across(where(is.numeric), get_sem))
  prob.mean <- as.data.frame(t(prob.mean))
  colnames(prob.mean) <- "mean_prob"
  prob.sd <- as.data.frame(t(prob.sd))
  colnames(prob.sd) <- "std_prob"
  df <- cbind(prob.mean, prob.sd)
  df <- rownames_to_column(df, var = "pos")
  
  return(df)
  
}

get_metaprofile_dataframe <- function(prob.file, shuff.file = NULL, shuffled = FALSE) {
  
  prob.name <- str_split(prob.file, pattern = "\\/")[[1]]
  prob.name <- prob.name[length(prob.name)]
  prob.name <- str_to_upper(str_split(prob.name, pattern = "_")[[1]][1]) # generate RBP name
  
  # Load metaprofile dataframes (df output from get_structure_metaprofile.R)
  rbp.prob.df <- fread(prob.file, skip = 1, data.table = FALSE)
  rbp.prob.df <- column_to_rownames(rbp.prob.df, var = "V1")
  rbp.prob.df <- drop_na(rbp.prob.df)
  colnames(rbp.prob.df) <- seq(1-(ncol(rbp.prob.df)+1)/2, (ncol(rbp.prob.df)-1)/2) # center colnames on zero
  
  rbp.prob.mean.df <- get_metaprofile_mean(prob.file)
  rbp.prob.mean.df$Sample <- prob.name
  
  if (shuffled == TRUE) {
   
    rbp.shuff.mean.df <- get_metaprofile_mean(shuff.file)
    rbp.shuff.mean.df$Sample <- "Shuffled"
    rbp.data.df <- rbind(rbp.prob.mean.df, rbp.shuff.mean.df)
    rbp.data.df$peaks_count <- nrow(rbp.prob.df)
  } else {
    rbp.data.df <- rbp.prob.mean.df
    rbp.data.df$peaks_count <- nrow(rbp.prob.df)
  }

return(rbp.data.df)
  
}


run_kmeans <- function(data, k) {
  
  set.seed(123)
  data.kmeans <- kmeans(data, centers = k, iter.max = 30)
  data <- augment(data.kmeans, data) #%>% arrange(.cluster)
  data <- data %>% add_count(.cluster, name = "cluster_size") %>%
    column_to_rownames(var = ".rownames")
  
  return(data)
  
}

```

#### Functions: plotting

```{r}
plot_metaprofile <- function(data.df) {
  
  profile.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
    geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob)), color = "grey80", fill = "grey80") +
    geom_line(aes(linetype = Sample)) +
    scale_linetype_manual(values=c("longdash", "solid")) +
    scale_color_manual(values=c('#E69F00', '#222222')) +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    ylim(c(0.40, 0.60)) +
    xlab("Distance relative to the peak start (nt)") +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Mean probability") +
    labs(linetype = "Sample") +
    geom_text(aes(x = 55,y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 4)
  
  return(profile.gg)
  
}


plot_cluster_heatmap <- function(cluster.df, plot.title, plot.name) {
  
  cluster.df <- cluster.df %>% arrange(.cluster)
  clust.mx = as.matrix(dplyr::select(cluster.df, -c(.cluster, cluster_size))) # get numeric matrix
  annotation.df <- dplyr::select(cluster.df, .cluster)
  gaps_row = cumsum(unique(cluster.df$cluster_size))
  mat_colors <- list(group = col_pal)
  names(mat_colors$group) <- unique(annotation.df$.cluster)
  heatmap <- pheatmap(clust.mx,cluster_cols = FALSE, cluster_rows = FALSE, show_rownames = FALSE,
                      color = mako(200),
                      gaps_row = gaps_row, fontsize_col = 3.5, annotation_row = annotation.df, border_color = FALSE,
                      annotation_colors = list(.cluster = mat_colors$group), angle_col = "45",
                      main = plot.title, filename = plot.name)
  return(heatmap)
  
}

# cl = dataframe containing nt position probabilities +  a "cluster" column and a "cluster_size" column
plot_cluster_mean <- function(cl, left_flank) {
  
  clust.m <- melt(cl)
  clust.mean <- dcast(clust.m, cluster ~ variable, mean)
  
  clust.mean.m <- melt(clust.mean, id=c("cluster","cluster_size")) # arrange the df to long format for facet_wrap plotting
  
  clust.mean.profiles <- ggplot(data = clust.mean.m, aes(x = as.numeric(variable)-left_flank, y = value, color=cluster)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    geom_hline(yintercept = 0.5, linetype = "dashed", color ="grey84", size = 0.5) +
    facet_wrap(~ cluster, ncol = 1, scales = "free_x") +   #scales = "free_y"
    xlab("Distance relative to the peak start (nt)") +
    ylab("Mean probability")+
    scale_color_manual(values = col_pal)+
    theme(text = element_text(size=14),
          strip.text = element_text(size=10, face = "bold"),
          plot.title = element_text(size = 14, face = "bold"),
          axis.text.x = element_text(angle = 60, hjust = 1)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  # rename legend title and add the number of observations in each cluster:
  clust.mean.profiles <- clust.mean.profiles +
    guides(color=guide_legend(title='Cluster')) +
    geom_text(data=clust.mean, aes(x=20,y=0.74,label=paste0("n = ",cluster_size)), inherit.aes=FALSE, size=3)
  
  return(clust.mean.profiles)
  
}

calculate_percentage <- function(data.df, column, group = NULL) {
  
  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    #arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts))) %>%
    mutate(percentage = as.numeric(sub("%","", percentage)))
  
  return(data_counts.df)
  
}
```

#### Functions: defining duplexes from RNAplfold clusters

```{r}
get_duplex <- function(region.dt, cluster_number, cores = 4) {

  # Cluster 1 = 1-30 & 30-51
  # Cluster 2 = 8-36 & 36-63
  # Cluster 3 = 16-43 & 43-67
  
  if(cluster_number == 1) {
    
    c.L_start <- 1
    c.L_end <- 30
    c.R_start <- 31
    c.R_end <- 51
    
  } else if(cluster_number == 2) {
    
    c.L_start <- 8
    c.L_end <- 36
    c.R_start <- 37
    c.R_end <- 63    
    
  } else if(cluster_number == 3) {
    
    c.L_start <- 16
    c.L_end <- 43
    c.R_start <- 44
    c.R_end <- 67     
    
  } else {
    
    stop("cluster_number should be 1, 2, or 3")
    
  }
    
  c.dt <- region.dt[cluster == cluster_number]
  
  c.dt[strand == "+", 
        `:=` (L_start = xlink + c.L_start,
              L_end = xlink + c.L_end,
              R_start = xlink + c.R_start,
              R_end = xlink + c.R_end)]
  c.dt[strand == "-", 
        `:=` (L_end = xlink - c.L_start,
              L_start = xlink - c.L_end,
              R_end = xlink - c.R_start,
              R_start = xlink - c.R_end)] # start and end flipped for GRanges
  
  L.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = L_start, end = L_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  R.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = R_start, end = R_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  L.gr$seq <- as.character(getSeq(Hsapiens, L.gr))
  R.gr$seq <- as.character(getSeq(Hsapiens, R.gr))
  
  c.duplex.l <- mclapply(seq_along(L.gr), 
                         function(peak) analyse_structure(L.gr$name[peak], L.gr$seq[peak], R.gr$seq[peak]),
                         mc.cores = cores)
  
  c.duplex.dt <- rbindlist(c.duplex.l)
  c.duplex.dt <- merge(c.dt, c.duplex.dt, by = "name")
  c.duplex.dt$loop <- str_count(str_extract(c.duplex.dt$structure, "\\.*&\\.*"), "\\.")
  
  return(c.duplex.dt)
  
}

```

#### Functions: coordinate conversion

```{r}
resize_peaks <- function(bedfiles.list, left = 100, right = 100) {
  
  w <- left + right + 1  # width of interval: xl site + flanks
  
  grl <- GRangesList(lapply(bedfiles.list, import.bed))
  gr <- unlist(grl)
  gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")
  gr <- dropSeqlevels(gr, c("chrM", "chrY"), pruning.mode = "coarse")
  
  gr <- resize(gr, width = 1, fix = "start") # resize the peaks, start of peak = 1
  gr <- unique(gr)  # keep unique xl positions
  gr <- resize(resize(gr, width = right + 1, fix = "start"), width = w, fix = "end") # add +/- flanks
  gr$id <- paste0("ID", seq(1, length(gr)))
  
  return(gr)
  
}


merge_by_partial_string <- function(df1, df2) {
  
  df1$matchID = row.names(df1)
  df2$matchID = sapply(df2$gene_name, function(x) grep(x, df1$fasta_id)) # not very fast but ok
  
  df_merge = merge(df1, df2, by = "matchID")[-1]
  
  return(df_merge)
}


get_paired_regions <- function(id, L_db, R_db) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  l_start <- l_brackets[1]
  l_end <- l_brackets[length(l_brackets)]
  
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  r_start <- r_brackets[1]
  r_end <- r_brackets[length(r_brackets)]
  
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  results.ls <- list(id = id, l_start = l_start, l_end = l_end, 
                     r_start=r_start, r_end=r_end)
  
  return(results.ls)
  
}


trim_duplex_overhangs <- function(clusters.df) {
  
  # Separate L_db and R_db
  clusters.df <- clusters.df %>%
    separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)
  
  # Get positions of paired residues within structures of each arm
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(paired_regions = list(get_paired_regions(id, L_db, R_db))) %>%
    mutate(L_duplex_start = paired_regions$l_start, 
           L_duplex_end = paired_regions$l_end,
           R_duplex_start = paired_regions$r_start, 
           R_duplex_end = paired_regions$r_end) %>%
    ungroup() %>%
    dplyr::select(-paired_regions)
  
  # Adjust genomic coordinates to only include the paired region
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(L_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_start - 1,
                                      TRUE ~ L_genomic_end - L_duplex_end + 1),
           L_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_end - 1,
                                    TRUE ~ L_genomic_end - L_duplex_start + 1),
           R_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_start - 1,
                                      TRUE ~ R_genomic_end - R_duplex_end + 1),
           R_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_end - 1,
                                    TRUE ~ R_genomic_end - R_duplex_start + 1)) %>%
    ungroup()
  
  return(clusters.df)
}
```


#### Data

***
> Data directories

```{r}
ref.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/ref"

data.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/results_nornase"
plots.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/revisions/plots/figure_3"

Hsapiens <- BSgenome.Hsapiens.UCSC.hg38
```

***
> Annotations

```{r warning=FALSE}
txdb <- paste0(ref.dir,"/gencode.v33.txdb.sqlite")
gencode.txdb <- AnnotationDbi::loadDb(txdb)
human.gtf <- paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz") # contains fasta_id used by Tosca
regions.gr <- import.gff2(paste0(ref.dir,"/icount_mini_utr3/regions.gtf.gz"))
genes.gr <- import.gff2(paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz"))
```

***
> Probablility profiles

```{r}
prob.files <- list.files(paste0(data.dir,""), pattern = "_prob_profiles.tsv.gz", full.names = TRUE)
shuff.files <- prob.files[str_detect(prob.files, "shuffled")]
prob.files <- prob.files[!str_detect(prob.files, "shuffled")]
shuffled <- TRUE

prob.files
shuff.files
```

***
> Annotated peaks

```{r}
bed.files <- list.files(path = paste0(data.dir,""), pattern = "annot.bed.gz", full.names = TRUE)
stau1.bedfile <- bed.files[str_detect(bed.files, "stau1")]
```


# Fig 3 A: STAU1 peaks regional distribution

```{r}
peaks.gr <- import.bed(stau1.bedfile)
peaks.gr <- keepStandardChromosomes(peaks.gr, pruning.mode = "coarse")
peaks.gr <- dropSeqlevels(peaks.gr, c("chrM", "chrY"), pruning.mode = "coarse")

# Get region type
overlap <- findOverlaps(peaks.gr, regions.gr)
regions.gr$type <- as.character(regions.gr$type)

peaks.gr$type <- as.character(NA)
peaks.gr[queryHits(overlap)]$type <- regions.gr[subjectHits(overlap)]$type

peak_regions.df <- as.data.frame(peaks.gr)
peak_regions.df$id <- rownames(peak_regions.df)

peak_regions.df$type <- factor(peak_regions.df$type, levels = c("UTR5", "CDS", "intron", "UTR3", "ncRNA"))

region_colours <- c("ncRNA" = "#fbb04e", "intron" = "#bfbb60", "UTR5" = "#a2ceaa",
                    "rRNA" = "#4f6980", "UTR3" = "#f47942", "CDS" = "#638b66",
                    "tRNA" = "#849db1")

regions_percentage.df <- calculate_percentage(peak_regions.df, column = type)
regions_percentage.df$type <- factor(regions_percentage.df$type, levels = c("UTR5", "CDS", "intron", "UTR3", "ncRNA"))

peak_regions.gg <- ggplot(regions_percentage.df, aes(x = "", y = percentage, fill = type)) +
  geom_bar(stat = "identity", width = 0.5) +
  geom_text(aes(label=ifelse(percentage >= 5, paste0(round(percentage, 1),"%"),"")),
                position=position_stack(vjust=0.5), colour="white") +
  coord_flip() +
  scale_fill_manual(values = region_colours) +
  theme_minimal_grid() + theme(legend.position = "top") +
  labs(x = "",
       y = "Percentage of peaks",
       fill = "") +
  scale_y_reverse()
peak_regions.gg
ggsave(paste0(plots.dir, "/stau1_peak_regions.pdf"), peak_regions.gg, width = 8, height = 3)
```

# Fig 3 B: STAU1 unpaired probability metaprofile

STAU1:

```{r}
stau1.prob.file <- prob.files[str_detect(prob.files, "stau1")]
stau1.shuff.file <- shuff.files[str_detect(prob.files, "stau1")]
prefix <- basename(stau1.prob.file)
prefix <- str_split(prefix, ".tsv")[[1]][1]
stau1.data.df <- get_metaprofile_dataframe(stau1.prob.file, stau1.shuff.file, shuffled = TRUE)
```

TDP-43:

```{r}
tardp.prob.file <- prob.files[str_detect(prob.files, "tdp43")]
tardp.shuff.file <- shuff.files[str_detect(prob.files, "tdp43")]

tardp.data.df <- get_metaprofile_dataframe(tardp.prob.file, tardp.shuff.file, shuffled = FALSE)
```

HuR:

```{r}
hur.prob.file <- prob.files[str_detect(prob.files, "hur")]
hur.shuff.file <- shuff.files[str_detect(prob.files, "hur")]
hur.data.df <- get_metaprofile_dataframe(hur.prob.file, hur.shuff.file, shuffled = FALSE)
```


```{r}
## Combine all RBPs
# Get number of peaks
stau1.counts <- unique(stau1.data.df$peaks_count)
hur.counts <- unique(hur.data.df$peaks_count)
tardp.counts <- unique(tardp.data.df$peaks_count)

hur.data.df$Experiment <- as.factor("HuR")
tardp.data.df$Experiment <- as.factor("TDP-43")
stau1.data.df$Experiment <- as.factor("STAU1")

merged.data.df <- rbind(stau1.data.df, hur.data.df, tardp.data.df)
data.df <- merged.data.df %>%
  dplyr::filter(!((Sample == "Shuffled" & Experiment == "HuR") | (Sample == "Shuffled" & Experiment == "TDP-43")))
data.df$Sample <- plyr::mapvalues(data.df$Sample, from=c("HUR", "TDP43"), to=c("HuR", "TDP-43"))
data.df$Sample <- factor(data.df$Sample, levels = c("Shuffled", "HuR", "STAU1", "TDP-43"))

merged.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
  scale_fill_manual(values=c('#ce5d5d','#575756', '#ce5d5d', '#878787')) +
  scale_color_manual(values=c('#ce5d5d','#575756', '#ce5d5d', '#878787')) +
  geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob), fill = Sample), alpha = 0.3, color = NA) +
  geom_line(aes(linetype = Sample)) +
  scale_linetype_manual(values=c("dotted", "solid","solid", "solid" )) +
  geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
  ylim(c(0.40, 0.60)) +
  xlab("Distance relative to the peak start (nt)") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme_minimal_grid() +
    ylab("Mean paired probability") +
    labs(linetype = "Sample") +
    # geom_text(aes(x = 55, y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 3) 
  geom_text(aes(x = -80, y = 0.43,label = paste0("n = ", hur.counts)), inherit.aes = FALSE, size = 4, color = "#575756") +
  geom_text(aes(x = -80, y = 0.415,label = paste0("n = ", stau1.counts)), inherit.aes = FALSE, size = 4, color = "#ce5d5d") +
  geom_text(aes(x = -80, y = 0.40,label = paste0("n = ", tardp.counts)), inherit.aes = FALSE, size = 4, color = "#878787") 

merged.gg <-
  append_layers(merged.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#b2b2b2"), position = "bottom")
merged.gg <- merged.gg + theme(strip.background = element_blank())
merged.gg

ggsave(paste0(plots.dir,"/RBPs_paired_metaprofile.pdf"), merged.gg, width = 6.5, height = 4, dpi = 300)
```

# Fig 3 C: STAU1 unpaired probability clusters

```{r}
# Load metaprofile dataframes (df output from get_structure_metaprofile.R)
stau1.prob.df <- fread(stau1.prob.file, skip = 1, data.table = FALSE)
stau1.prob.df <- column_to_rownames(stau1.prob.df, var = "V1")
colnames(stau1.prob.df) <- seq(1-(ncol(stau1.prob.df)+1)/2, (ncol(stau1.prob.df)-1)/2) # center column names on zero
stau1.prob.df <- drop_na(stau1.prob.df)

# ==========
# K-means clustering
# ==========
# Focus on the -50 to +75 nt relative to peak starts:
stau1.prob.df <- stau1.prob.df %>% dplyr::select("-50":"75")

# Convert unpaired probablity to paired probability
stau1.prob.df <- stau1.prob.df %>%
  mutate_if(is.numeric, convert_probability)

# Focus on the +10 to +75 nt relative to peak starts:
prob_downstream.df <- stau1.prob.df %>% dplyr::select("10":"75")
```

## Suppl. Fig 3 A: Find the optimal number of clusters:

```{r}
set.seed(123)
silhouette.gg <- fviz_nbclust(prob_downstream.df, run_kmeans, method="silhouette")
silhouette.gg
ggsave(paste0(plots.dir,"/silhouette_plot.pdf"), silhouette.gg, dpi = 300, width = 4, height = 4)
```
Based on the silhouette plot clustering the peaks paired probability profiles in 2 clusters is optimal.

```{r}
n_clusters <- 2
```

Number of clusters for K-means clustering: `{r} n_clusters`

```{r  warning=FALSE, message=FALSE}
# K-means clustering - "euclidean" dist, 2 clusters
kmeans.df <- run_kmeans(prob_downstream.df, n_clusters)

# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(stau1.prob.df))
stau1.prob.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
stau1.prob.df$cluster_size <- kmeans.df$cluster_size

stau1.prob.df$cluster <- plyr::mapvalues(stau1.prob.df$cluster, from=c(1, 2), to=c(0, 1))
stau1.prob.df <- dplyr::arrange(stau1.prob.df, cluster)
stau1.prob.df$cluster <- factor(stau1.prob.df$cluster, levels = c(0, 1))

# Visualise the two clusters'means
col_pal <- brewer.pal(n_clusters, "Dark2")
clusters.gg <- plot_cluster_mean(stau1.prob.df, 51) +
  theme_minimal_grid()
clusters.gg
```

Cluster 1 contains STAU1 peaks with higher paired probability. To further subset peaks based on the paired probability profiles, we will sub-cluster cluster 1.

```{r}
# Select cluster 1
cluster1.df <- stau1.prob.df %>%
  dplyr::filter(cluster == 1) %>%
  dplyr::select(-cluster, -cluster_size) 

# Focus on the region +10 to +75 nt relative to peak starts:
cluster1.df_downstream.df <- cluster1.df %>%
  dplyr::select("10":"75")

# Find the optimal number of clusters
set.seed(123)
silhouette_cl1.gg <- fviz_nbclust(cluster1.df_downstream.df, run_kmeans, method="silhouette")
silhouette_cl1.gg
# ggsave(paste0(plots.dir,"/silhouette_cluster1.pdf"), silhouette_cl1.gg, dpi = 300, width = 4, height = 4)
```
We will subluster cluster 1 into 3 clusters

```{r}
# K-means clustering - "euclidean" dist, 3 clusters
kmeans.df <- run_kmeans(cluster1.df_downstream.df, 3)
# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(cluster1.df))
cluster1.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
cluster1.df$cluster_size <- kmeans.df$cluster_size
```


```{r}
cluster1.df$cluster <- factor(cluster1.df$cluster, levels = c(1, 2, 3))
cluster1.df <- cluster1.df %>%
  dplyr::rename(.cluster = cluster)

# Select cluster 0 and join
cluster0.df <- stau1.prob.df %>%
  dplyr::filter(cluster == "0") %>%
  dplyr::rename(.cluster = cluster)

# Merge back cluster 0 and the subclusters of cluster 1
clusters.df <- rbind(cluster0.df, cluster1.df)
clusters.df$.cluster <- plyr::mapvalues(clusters.df$.cluster, from = c(3, 2, 1, 0), to = c(1, 2, 3, 0))
clusters.df$.cluster <- factor(clusters.df$.cluster, levels = c(0, 1, 2, 3))

stopifnot(nrow(stau1.prob.df) == nrow(clusters.df)) # Check same size as original prob df
```

## Fig 3 C - heatmap

```{r}
col_pal <- brewer.pal(4, "Dark2")
plot_cluster_heatmap(clusters.df, plot.title = "STAU1", plot.name = paste0(plots.dir,"/",prefix,"_kmeans_paired_probability_clusters.png"))

# Export clusters data
clusters.df <- rownames_to_column(clusters.df, var = "id")
fwrite(clusters.df, paste0(data.dir, "/", prefix,"_clusters.tsv.gz"), sep = "\t")
```

Metaprofiles for each cluster: 

```{r warning=FALSE, message=FALSE}
clusters.df <- clusters.df %>%
  dplyr::rename(cluster = .cluster)

col_pal <- brewer.pal(4, "Dark2")
clusters.gg <- plot_cluster_mean(clusters.df, 51) +
  scale_y_continuous(position = "right") +
  theme(strip.background = element_blank(), strip.text.x = element_blank())
clusters.gg <- append_layers(clusters.gg, annotate("rect", xmin = 10, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#b2b2b2"), position = "bottom") +
  theme_minimal_grid()
clusters.gg
ggsave(paste0(plots.dir,"/",prefix,"_cluster_profiles.pdf"), clusters.gg, width = 3.5, height = 10)
```

Clusters 1,2,3 contain structures with higher paired probability downstream the xlink site, suggesting the presence of putative stems.


## Suppl. Fig 3 B: Define duplex arms for each cluster:

Define duplex arms:

```{r}
dt <- as.data.table(clusters.df[clusters.df$cluster != 0,])

p.list <- lapply(1:3, function(i) {
  
  message(i)
  
  m <- colMeans(dt[cluster == i, .SD, .SDcols = !c("id", "cluster", "cluster_size")])
  lmin <- which(diff(sign(diff(m))) == 2) + 1 -51
  lmin <- lmin[lmin > 0]
  names(lmin) <- NULL
  print(lmin)
  
  p <- ggplot(data = data.frame(coord = as.integer(names(m)), score = m), aes(x = coord, y = score)) +
    geom_line() +
    geom_vline(xintercept = lmin, linetype = "dashed", colour = "blue") +
    theme_minimal_grid() +
    labs(x = "Coordinate",
         y = "Mean pairing probability",
         title = paste("Cluster", i))
  
  return(p)
  
})

ggsave(plot_grid(plotlist = p.list, ncol = 1), filename = file.path(plots.dir, "sr_clusters_lmin.pdf"), width = 7, height = 10)
```


```{r}
# ==========
# Identify duplexes within arms
# ==========

# Load peaks data, resize exactly as for rnaplfold used to predict structures
peaks.gc.gr <- resize_peaks(stau1.bedfile, left = 100, right = 100)

# Save a record of the bed fie containing the peak ID
peaks.id.gr <- peaks.gc.gr
peaks.id.gr$name <- peaks.id.gr$id
peaks.id.gr$id <- NULL
export.bed(peaks.id.gr, paste0(data.dir, "/stau1.10nt_10nt.peaks.annot_id.bed.gz"))

peaks.dt <- as.data.table(peaks.id.gr)
peaks.dt <- merge(peaks.dt, dt[, .(id, cluster)], by.x = "name", by.y = "id")
# setnames(peaks.dt, ".cluster", "cluster")
peaks.dt[, xlink := start + 101]
```


```{r}
cluster.duplexes.l <- lapply(1:3, function(i) get_duplex(region.dt = peaks.dt,
                                                         cluster_number = i))
cluster.duplexes.dt <- rbindlist(cluster.duplexes.l)
fwrite(cluster.duplexes.dt, paste0(data.dir,"/short_range_lmin_rnaduplex_structures.tsv.gz"), sep = "\t")
# cluster.duplexes.dt <- fread(paste0(data.dir,"/short_range_lmin_rnaduplex_structures.tsv.gz") # The above chunk takes long to run, so you can load the data directly

# Match IDs to transcripts for which RNAplfold was ran
peaks.tx_annotated.df <- data.frame(peaks.gr)
peaks.tx_annotated.df <- peaks.tx_annotated.df %>%
  mutate(id = paste0("ID",rownames(peaks.tx_annotated.df))) %>%
  dplyr::rename(transcript_name = name)

cluster.duplexes.tx_annotated.dt <- left_join(cluster.duplexes.dt, dplyr::select(peaks.tx_annotated.df, id, transcript_name), by = c("name" = "id"))
```

Use peaks (IDs) in clusters 1, 2 and 3.
The short range duplexes were used using the local minima approach applied on each of clusters 1-3.
There are `r length(unique(cluster.duplexes.dt$name))` peaks in clusters 1,2,3.

***
> Convert genomic coordinates to tx

Get genomic and tx coordinates for the resized peaks that have been used for RNAplfold

```{r}
# ==========
# Prepare gene IDs and coordinates
# ==========

# Add a new column containing gene ids by directly mapping the transcript ids
keys = peaks.gc.gr$name
mapped.ids <- AnnotationDbi::select(gencode.txdb, keys = keys, columns="GENEID", keytype="TXNAME")
peaks.gc.gr$gene_name <- mapped.ids$GENEID

# Add fasta_id from tx annotation used for Tosca as a new column
human.gr <- import.gff2(human.gtf)
human.gr <- keepStandardChromosomes(human.gr, pruning.mode = "coarse")
human.gr <- dropSeqlevels(human.gr, c("chrM", "chrY"), pruning.mode = "coarse")
human.df <- as.data.frame(human.gr)
genes.ls <- unique(peaks.gc.gr$gene_name) # create list of unique gene names from peak file to filter the human annotation

human.df <- human.df %>%
  filter(str_detect(fasta_id, paste(genes.ls, collapse = "|"))) %>% # filter for gene names in the peak gr
  rownames_to_column(var = "row") %>%
  dplyr::rename(fasta_id_start = start, fasta_id_end = end) %>%
  dplyr::select(row, fasta_id, fasta_id_start, fasta_id_end)

peaks.gc.df <- as.data.frame(peaks.gc.gr)
peaks.gc.df <- merge_by_partial_string(as.data.frame(human.df), peaks.gc.df) %>%
  dplyr::select(-row)

# Add transcriptomic coordinates to the peaks file
peaks.df <- peaks.gc.df %>%
  mutate(tx_start = case_when((strand == "+") ~ start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - end + 1),
         tx_end = case_when((strand == "+") ~ end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - start + 1))%>%
  dplyr::rename(tx_name = name)
```


```{r}
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  dplyr::mutate(L_genomic_start = L_start, L_genomic_end = L_end, R_genomic_start = R_start, R_genomic_end = R_end)

# Extract the start and end position of the stem-loop individually for each arm
arms.df <- cluster.duplexes.dt %>% 
  dplyr::select(name, seqnames, strand, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, mfe, structure)

# Merge df containing the peaks starts + 100 in genomic and transcriptomic coordinates to arms dataframe
arms.df <- as.data.frame(left_join(arms.df, peaks.df, by = c("name" = "id", "seqnames", "strand")))


# From the annotated peaks coordinates calculate tx coordinates of the derived stem
# ==========
# Obtain coordinates for each arm of the stem loop
# ==========

# Calculate L and R arms transcriptomic coordinates
arms.df <- arms.df %>%
  mutate(L_tx_start = case_when((strand == "+") ~ L_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - L_genomic_end + 1),
         L_tx_end = case_when((strand == "+") ~ L_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - L_genomic_start + 1),
         R_tx_start = case_when((strand == "+") ~ R_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~ fasta_id_end - R_genomic_end + 1),
         R_tx_end = case_when((strand == "+") ~ R_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~ fasta_id_end - R_genomic_start + 1))

# The peaks with gene IDs not present in fasta_ids of human annotation will have NAs instead of coordinates, so filtering them out
arms.df <- dplyr::filter(arms.df, !is.na(fasta_id))

# Check L and R arm coordinate widths are correct
stopifnot((arms.df$L_genomic_end - arms.df$L_genomic_start) == abs(arms.df$L_tx_end - arms.df$L_tx_start))
stopifnot((arms.df$R_genomic_end - arms.df$R_genomic_start) == abs(arms.df$R_tx_end - arms.df$R_tx_start))

# Genomic (similar to tosca clusters table):
short_range.df <- data.frame(name = arms.df$name, count = arms.df$score, L_seqnames=arms.df$fasta_id,	
                                     L_start=arms.df$L_tx_start, L_end=arms.df$L_tx_end, L_strand="+", L_genomic_seqnames=arms.df$seqnames,
                                     L_genomic_start=arms.df$L_genomic_start, L_genomic_end= arms.df$L_genomic_end,
                                     L_genomic_strand=arms.df$strand, R_seqnames=arms.df$fasta_id, R_start=arms.df$R_tx_start, R_end=arms.df$R_tx_end,
                                     R_strand="+", R_genomic_seqnames=arms.df$seqnames,
                                     R_genomic_start=arms.df$R_genomic_start,  R_genomic_end= arms.df$R_genomic_end,
                                     R_genomic_strand =arms.df$strand, structure = arms.df$structure, mfe = arms.df$mfe)

stopifnot(abs(short_range.df$L_genomic_end - short_range.df$L_genomic_start) ==
            abs(short_range.df$L_end - short_range.df$L_start))
stopifnot(abs(short_range.df$R_genomic_end - short_range.df$R_genomic_start) ==
            abs(short_range.df$R_end - short_range.df$R_start))

# Save short range derived interactions
fwrite(short_range.df, paste0(data.dir,"/short_range_duplexes.tsv.gz"), sep = "\t")
```

# Fig 3 D: Types of derived duplexes at STAU1 binding sites 

Trim dot bracket structure to focus only on the paired regions, and adjust genomic coordinates accordingly:

```{r}
# Get positions of paired residues within structures of each arm
short_range.df <- trim_duplex_overhangs(short_range.df)

short_range.df <- short_range.df %>%
  mutate(L_genomic_start = L_genomic_duplex_start, L_genomic_end = L_genomic_duplex_end,
         R_genomic_start = R_genomic_duplex_start, R_genomic_end = R_genomic_duplex_end) %>%
  dplyr::select(.,-contains("_genomic_duplex_")) %>%
  rowwise() %>%
  mutate(hairpin_loop = case_when(L_genomic_strand == "+" ~ R_genomic_start - L_genomic_end + 1 - 2,
                                  TRUE ~ L_genomic_start - R_genomic_end + 1 - 2)) %>%
  ungroup()

short_range.df <- dplyr::filter(short_range.df, hairpin_loop != 0) # remove loops = 0 as they suggest homo-heterodimers rather than stem loops

# Also adjust tx coordinates
short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(L_tx_duplex_start = L_start + L_duplex_start - 1, R_tx_duplex_start = R_start + R_duplex_start - 1,
         L_tx_duplex_end = L_start + L_duplex_end - 1, R_tx_duplex_end = R_start + R_duplex_end - 1) %>%
  ungroup() %>%
  mutate(L_start = L_tx_duplex_start, R_start = R_tx_duplex_start, L_end = L_tx_duplex_end, R_end = R_tx_duplex_end) %>%
  dplyr::select(.,-contains("_tx_duplex_"))

cluster.duplexes.dt <- cluster.duplexes.dt %>%
  dplyr::filter(name %in% short_range.df$name) 
```

Obtain duplex length:

```{r}
# Calculate number of paired residues
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  rowwise() %>%
  mutate(total_paired = str_count(structure, "\\(")) %>%
  ungroup()

quantile(cluster.duplexes.dt$total_paired, c(.25, .50, .75, 1))
nrow(cluster.duplexes.dt)
```

Separate duplexes: very short (less than 8 bp) and longer residues

```{r}
m_motif_structures <- list(nrow(cluster.duplexes.dt))
names(m_motif_structures) <- "M motif duplexes (clusters 1, 2, 3)"
m_motif_min8bp <- list(nrow(cluster.duplexes.dt[cluster.duplexes.dt$total_paired >= 8,]))
names(m_motif_min8bp) <-"M motif duplexes >= 8 bp"
m_motif_max7bp <- list(nrow(cluster.duplexes.dt) - nrow(cluster.duplexes.dt[cluster.duplexes.dt$total_paired >= 8,]))
names(m_motif_max7bp) <- "M motif duplexes < 8 bp"
no_m_motif <- list(nrow(stau1.prob.df) - nrow(cluster.duplexes.dt))
names(no_m_motif) <- "No M motif"
structure_types.ls <- c(no_m_motif, m_motif_max7bp, m_motif_min8bp)

derived_types.df <- data.frame(structure_types = names(structure_types.ls), count = unlist(structure_types.ls, use.names=FALSE))
derived_type_counts.df <- derived_types.df %>%
  mutate(percentage = scales::percent(count / sum(count))) %>%
  mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
  mutate(pos = cumsum(percentage) - percentage/2)

types_colours <- c("No M motif" = "#216b77", "M motif duplexes >= 8 bp" = "#31a1b3", "M motif duplexes < 8 bp" = "#cbbba0")
pie.gg <- ggplot(derived_type_counts.df, aes(x="", y=count, fill=reorder(structure_types, count))) +
    geom_bar(stat = "identity", width = 0.05, color="black") +
    coord_polar("y", start=0) +
    #scale_fill_brewer(palette = "Blues", direction = -1) +
    scale_fill_manual(values = types_colours) +
    ggrepel::geom_label_repel(aes(label = paste0(percentage,"%")), size = 3.5, show.legend = FALSE, position = position_stack(vjust = .5)) +
    ggrepel::geom_label_repel(aes(label = count), size = 2.5, show.legend = FALSE, position = position_stack(vjust = .3)) +
    guides(fill = guide_legend(title = "Structure type")) +
    theme_void() # remove background, grid, numeric labels

pie.gg
ggsave(paste0(plots.dir,"/",prefix,"_structure_types.pdf"), pie.gg, width = 5, height = 4, dpi = 300)
```

```{r}
# Work with the annotated structures from here onwards:
short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(total_paired = str_count(L_db, "\\(")) %>%
  ungroup() %>%
  mutate(structure_type = case_when(total_paired < 8 ~ "M motif duplexes < 8 bp",
                                    TRUE ~ "M motif duplexes >= 8 bp"))

```


# Fig 3 E: Hybridisation energy

```{r}
# Need to run 
mfe <- fread(paste0(data.dir, "/short_range_duplexes.mfe.tsv.gz")) # analyse_clusters_structure.R output ran on exported "short_range_duplexes.tsv.gz"
# stopifnot(nrow(short_range.df) == nrow(mfe))
mfe <- dplyr::filter(mfe, !(str_detect(L_sequence, "N") | str_detect(R_sequence, "N")))
short_range.df <- left_join(short_range.df, dplyr::select(mfe, L_sequence, R_sequence, name, mean_shuffled_mfe), by = "name") %>%
  mutate(mean_shuffled_mfe = as.numeric(mean_shuffled_mfe), mfe = as.numeric(mfe))

mfe.df <- pivot_longer(short_range.df, cols = c(mfe, mean_shuffled_mfe), names_to = "Sample", values_to = "MFE") %>%
  mutate(Sample = case_when((Sample == "mfe") ~ "STAU1",
                            (Sample == "mean_shuffled_mfe") ~ "Shuffled control"))

mfe_median <- short_range.df %>%
  group_by(structure_type) %>%
  dplyr::summarize(Median = median(mfe, na.rm = TRUE))

mfe_median

bp_colours <- c("M motif duplexes >= 8 bp" = "#31a1b3", "M motif duplexes < 8 bp" = "#cbbba0")

mfe.dens.gg <- ggplot(mfe.df, aes(x = MFE, linetype = Sample, color = structure_type)) + 
  geom_density() + # color = c("#31a1b3", "#5ec3d3")
  # annotate("text", label = "p < 2.2e-16", x = -1, y = 1.7) +
  scale_linetype_manual(values=c("longdash", "solid")) +
  scale_color_manual(values = bp_colours) +
  theme(legend.position = "right") +
  theme_minimal_grid() + 
  ylab("Density") +
  xlab("Hybridisation energy (kcal/mol)") 
  # geom_vline(data=mfe_median, aes(xintercept=Median), linetype="dashed", color = "#31a1b3" )

mfe.dens.gg
ggsave(paste0(plots.dir,"/","stau1_short_range_hybridisation_energy.pdf"), mfe.dens.gg, width = 7, height = 4)
```


```{r}
# Add stats:
stau1.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes >= 8 bp")$mfe
stau1.shuffled.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes >= 8 bp")$mean_shuffled_mfe
wilcox.test(stau1.mfe.ls, stau1.shuffled.mfe.ls)


mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes < 8 bp")$mfe
shuffled.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes < 8 bp")$mean_shuffled_mfe
wilcox.test(mfe.ls, shuffled.mfe.ls)
```

# Fig 3 F: Hairpin loop size
Focus on structures with more than 8 base pairs:

```{r}
short_range.df <- short_range.df %>%
  dplyr::filter(structure_type == "M motif duplexes >= 8 bp")

hairpin_median <- short_range.df %>%
  dplyr::summarize(Median = median(hairpin_loop, na.rm = TRUE))
hairpin_median

# Plot
hairpin.gg <- ggplot(short_range.df, aes(x = hairpin_loop)) + 
  #geom_histogram(bins = 45, color="black", fill = "#DEEBF7") +
  geom_density(color = "#31a1b3", bw = 0.1) +
  theme_minimal_grid() +
  geom_vline(data=hairpin_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  scale_x_log10() + annotation_logticks(sides = "b") + #breaks=c(3,5,7, 10,30))
  # ggtitle("Distribution of hairpin loop sizes") +
  xlab("Hairpin loop size (nt)") +
  ylab("Density")

hairpin.gg
ggsave(paste0(plots.dir,"/", prefix,"_hairpin_lengths.pdf"), hairpin.gg, width = 4, height = 4)

quantile(short_range.df$hairpin_loop, c(.25, .50, .75, 1))
```
Export data (this table will be used for creating the complete atlas)!ß

```{r}
fwrite(short_range.df, paste0(data.dir,"/short_range_duplexes_min8bp.tsv.gz"), sep = "\t")
```

# Fig 3 G:  Breakdown of the atlas & overlap with duplexes from STAU1 hybrid reads

Load experimental (linker and direct) duplexes - this needs to be generated from the linker and nolinker hybrids 

```{r}
data.dir <- "/Volumes/lab-luscomben/home/shared/projects/ira-nobby/comp_hiclip/revisions/atlas/"
stau1.collapsed.dt <- fread(paste0(data.dir, "merged.atlas.clusters.tsv.gz"))
stau1.clustered.dt <- fread(paste0(data.dir, "merged.atlas.clustered.tsv.gz"))

# Total number of clusters
nrow(stau1.collapsed.dt)

# Total number of clustered hybrids
nrow(dplyr::filter(stau1.clustered.dt, str_detect(cluster, "C")))
```


```{r}
stau1.cluster.hybrids.df <- stau1.clustered.dt %>%
  mutate(cluster = case_when(sample == "stau1_derived" & !str_detect(cluster, "C") ~ name, # rename clusters for derived duplexes which havent been clustered
                             TRUE ~ cluster)) %>%
  rowwise() %>% # create an id column to be consistent with the name column of the collapsed clusters table
  mutate(id = case_when(cluster == name ~ cluster, # these are the ID ones
                        TRUE ~ paste(cluster, L_seqnames, R_seqnames, sep = "-"))) %>%
  ungroup()
```

How many duplexes are supported by multiple sources?

```{r}
# Assign samples to all hybrids
stau1.cluster.hybrids_summary.df <- stau1.cluster.hybrids.df %>%
  group_by(id) %>%
  summarize(sample_set = paste(sort(unique(sample)), collapse=",")) %>%
  ungroup() 
# fwrite(stau1.cluster.hybrids_summary.df, paste0(data.dir, "/stau1.cluster.hybrids_summary.tsv.gz", sep = "\t"))
stau1.samples.df <- stau1.cluster.hybrids_summary.df %>%
  dplyr::select(id, sample_set) %>%
  distinct()
```


```{r}
source_counts.df
```


```{r}
stau1.collapsed.dt <- left_join(stau1.collapsed.dt, dplyr::select(stau1.samples.df, id, sample_set), by = c("name" = "id"))

# Get counts for each duplex dataset and combinations
source_counts.df <- stau1.collapsed.dt %>%
  dplyr::select(name, sample_set) %>%
  distinct() %>%
  group_by(sample_set) %>%
  summarise(counts = n()) 

source_counts.df # input for upset plot below
stopifnot(nrow(stau1.collapsed.dt) == sum(source_counts.df$counts))

theme_set(theme_minimal_grid())
ht_colours <- c("Linker" = "#8175aa", "Direct" = "#6fb899", "Derived" = "#31a1b3")

source.upset.input <- c("Linker" = source_counts.df[source_counts.df$sample_set == "stau1_linker",]$counts[1],
                        "Direct" = source_counts.df[source_counts.df$sample_set == "stau1_nolinker",]$counts[1],
                        "Derived" = source_counts.df[source_counts.df$sample_set == "stau1_derived",]$counts[1],
                        "Linker&Direct" = source_counts.df[source_counts.df$sample_set == "stau1_linker,stau1_nolinker",]$counts[1],
                        "Linker&Derived" = source_counts.df[source_counts.df$sample_set == "stau1_derived,stau1_linker",]$counts[1],
                        "Direct&Derived" = source_counts.df[source_counts.df$sample_set == "stau1_derived,stau1_nolinker",]$counts[1],
                        "Linker&Direct&Derived" = source_counts.df[source_counts.df$sample_set == "stau1_derived,stau1_linker,stau1_nolinker",]$counts[1])

pdf(file.path(plots.dir, "stau1_duplex_source_upset.pdf"), width = 7, height = 5)
upset(fromExpression(source.upset.input), order.by = "freq",
      mainbar.y.label = "Intersecting number of duplexes",
      sets.x.label = "Total number of duplexes",
      sets.bar.color=rev(ht_colours))
dev.off()
```

Some numbers:

```{r}
# Breakdown of M motif structures
dplyr::filter(stau1.dt, sample_set == "stau1_derived") # M motif unclustered
dplyr::filter(stau1.dt, sample_set == "stau1_derived" & str_detect(cluster, "C")) # M motif structures clustering together

# Number of M motif duplexes not forming clusters:
nrow(stau1.dt %>% dplyr::filter(str_detect(cluster, "ID")))

# Number of M motif hybrids not forming clusters:
nrow(dplyr::filter(stau1.hybrids.dt, sample == "stau1_derived" & !str_detect(cluster, "C")))


# Number of hybrids from M motif structures (sum of clustered + unclustered)
nrow(dplyr::filter(stau1.hybrids.dt, sample == "stau1_derived"))

# all M motif hybrids that have been clustered
nrow(dplyr::filter(stau1.hybrids.dt, sample == "stau1_derived" & str_detect(cluster, "C")))
```

# Extras

Are the loops of overlapped derived duplexes larger than the loops of non-overlapped derived duplexes? (asked by Flora)

```{r}
derived_only.dt <- stau1.cluster.hybrids.df %>% dplyr::filter(str_detect(cluster, "ID"))
derived_only.df <- semi_join(short_range.df, derived_only.dt, by = "name")
derived_overlapped.df <- anti_join(short_range.df, derived_only.dt, by = "name")
quantile(derived_only.df$hairpin_loop, c(.25, .50, .75, 1))
quantile(derived_overlapped.df$hairpin_loop, c(.25, .50, .75, 1))
```

Number of paired residues for derived structures

```{r}
total_paired_median <- short_range.df %>%
  dplyr::summarize(Median = median(total_paired, na.rm = TRUE))
total_paired_median

# Plot
total_paired.gg <- ggplot(short_range.df, aes(x=total_paired)) + 
  geom_density(color = "#31a1b3", bw = 1.5) +
  theme_minimal_grid() +
  geom_vline(data=total_paired_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  xlab("Paired residues") +
  ylab("Density")

total_paired.gg
```

Number of hybrids supporting duplexes: linker vs whole atlas

```{r}
linker.dt <- fread("~/Dropbox (The Francis Crick)/comp_hiclip/hiclip/linker/linker.clusters.mfe.tsv.gz")
linker.clusters.dt <- collapse_clusters(linker.dt)
nrow(linker.clusters.dt)
nrow(stau1.dt)
mean(stau1.dt$count)
mean(linker.clusters.dt$count)

median(stau1.dt$count)
median(linker.clusters.dt$count)
```

```{r}
installed.packages()[names(sessionInfo()$otherPkgs), "Version"]
```

