---
title: "Figure 3 & related"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(rematch))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(broom))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(primavera))
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(gginnards))
suppressPackageStartupMessages(library(factoextra))
suppressPackageStartupMessages(library(BSgenome.Hsapiens.UCSC.hg38))
theme_set(theme_bw() +
            theme(legend.position = "top"))
```

```{r}
Hsapiens <- BSgenome.Hsapiens.UCSC.hg38
```

#### Functions: metaprofiles and clustering

```{r}
convert_probability <- function(x, na.rm = FALSE) (1 - x)

get_sem <- function(x) sd(x)/sqrt(length(x))

get_metaprofile_mean <- function(filename) {
  
  prob.df <- read.csv(filename, sep="\t")
  prob.df <- column_to_rownames(prob.df, var = "X")
  colnames(prob.df) <- seq(1:ncol(prob.df)) - (ncol(prob.df)+1)/2
  prob.df <- drop_na(prob.df, 0) # remove peaks sites with NAs at the xl site

  # Convert unpaired probability to paired probability
  prob.df <- prob.df %>%
  mutate_if(is.numeric, convert_probability)

  prob.mean <- prob.df %>% 
    summarise(across(where(is.numeric), mean))
  prob.sd <- prob.df %>% 
    summarise(across(where(is.numeric), get_sem))
  prob.mean <- as.data.frame(t(prob.mean))
  colnames(prob.mean) <- "mean_prob"
  prob.sd <- as.data.frame(t(prob.sd))
  colnames(prob.sd) <- "std_prob"
  df <- cbind(prob.mean, prob.sd)
  df <- rownames_to_column(df, var = "pos")
  
  return(df)
  
}

get_metaprofile_dataframe <- function(prob.file, shuff.file = NULL, shuffled = FALSE) {
  
  prob.name <- str_split(prob.file, pattern = "\\/")[[1]]
  prob.name <- prob.name[length(prob.name)]
  prob.name <- str_to_upper(str_split(prob.name, pattern = "_")[[1]][1]) # generate RBP name
  
  # Load metaprofile dataframes (df output from get_structure_metaprofile.R)
  rbp.prob.df <- fread(prob.file, skip = 1, data.table = FALSE)
  rbp.prob.df <- column_to_rownames(rbp.prob.df, var = "V1")
  rbp.prob.df <- drop_na(rbp.prob.df)
  colnames(rbp.prob.df) <- seq(1-(ncol(rbp.prob.df)+1)/2, (ncol(rbp.prob.df)-1)/2) # center colnames on zero
  
  rbp.prob.mean.df <- get_metaprofile_mean(prob.file)
  rbp.prob.mean.df$Sample <- prob.name
  
  if (shuffled == TRUE) {
   
    rbp.shuff.mean.df <- get_metaprofile_mean(shuff.file)
    rbp.shuff.mean.df$Sample <- "Control (shuffled)"
    rbp.data.df <- rbind(rbp.prob.mean.df, rbp.shuff.mean.df)
    rbp.data.df$peaks_count <- nrow(rbp.prob.df)
  } else {
    rbp.data.df <- rbp.prob.mean.df
    rbp.data.df$peaks_count <- nrow(rbp.prob.df)
  }

return(rbp.data.df)
  
}


run_kmeans <- function(data, k) {
  
  set.seed(123)
  data.kmeans <- kmeans(data, centers = k, iter.max = 30)
  data <- augment(data.kmeans, data) #%>% arrange(.cluster)
  data <- data %>% add_count(.cluster, name = "cluster_size") %>%
    column_to_rownames(var = ".rownames")
  
  return(data)
  
}

```

#### Functions: plotting

```{r}
plot_metaprofile <- function(data.df) {
  
  profile.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
    geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob)), color = "grey80", fill = "grey80") +
    geom_line(aes(linetype = Sample)) +
    scale_linetype_manual(values=c("longdash", "solid")) +
    scale_color_manual(values=c('#E69F00', '#222222')) +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    ylim(c(0.40, 0.60)) +
    xlab("Distance relative to the peak start (nt)") +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Mean probability") +
    labs(linetype = "Sample") +
    geom_text(aes(x = 55,y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 4)
  
  return(profile.gg)
  
}


plot_cluster_heatmap <- function(cluster.df, plot.title, plot.name) {
  
  cluster.df <- cluster.df %>% arrange(.cluster)
  clust.mx = as.matrix(dplyr::select(cluster.df, -c(.cluster, cluster_size))) # get numeric matrix
  annotation.df <- dplyr::select(cluster.df, .cluster)
  gaps_row = cumsum(unique(cluster.df$cluster_size))
  mat_colors <- list(group = col_pal)
  names(mat_colors$group) <- unique(annotation.df$.cluster)
  heatmap <- pheatmap(clust.mx,cluster_cols = FALSE, cluster_rows = FALSE, show_rownames = FALSE,
                      color = mako(200),
                      gaps_row = gaps_row, fontsize_col = 3.5, annotation_row = annotation.df, border_color = FALSE,
                      annotation_colors = list(.cluster = mat_colors$group), angle_col = "45",
                      main = plot.title, filename = plot.name)
  return(heatmap)
  
}

# cl = dataframe containing nt position probabilities +  a "cluster" column and a "cluster_size" column
plot_cluster_mean <- function(cl, left_flank) {
  
  clust.m <- melt(cl)
  clust.mean <- dcast(clust.m, cluster ~ variable, mean)
  
  clust.mean.m <- melt(clust.mean, id=c("cluster","cluster_size")) # arrange the df to long format for facet_wrap plotting
  
  clust.mean.profiles <- ggplot(data = clust.mean.m, aes(x = as.numeric(variable)-left_flank, y = value, color=cluster)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    geom_hline(yintercept = 0.5, linetype = "dashed", color ="grey84", size = 0.5) +
    facet_wrap(~ cluster, ncol = 1, scales = "free_x") +   #scales = "free_y"
    xlab("Distance relative to the peak start (nt)") +
    ylab("Mean probability")+
    scale_color_manual(values = col_pal)+
    theme(text = element_text(size=14),
          strip.text = element_text(size=10, face = "bold"),
          plot.title = element_text(size = 14, face = "bold"),
          axis.text.x = element_text(angle = 60, hjust = 1)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  # rename legend title and add the number of observations in each cluster:
  clust.mean.profiles <- clust.mean.profiles +
    guides(color=guide_legend(title='Cluster')) +
    geom_text(data=clust.mean, aes(x=20,y=0.74,label=paste0("n = ",cluster_size)), inherit.aes=FALSE, size=3)
  
  return(clust.mean.profiles)
  
}


plot_stacked_barchart <- function(data.df, column, group=NULL) {
  
  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts))) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
    mutate(pos = cumsum(percentage) - percentage/2)
  
  bar = ggplot() + geom_bar(aes(y = percentage, x = "", fill = {{column}}), data = data_counts.df,
                            stat="identity", width = 0.5) +
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = "", y = pos, label = paste0(round(percentage,1),"%")), size=5, nudge_x = 0.4,
                                 segment.size = 0.5, segment.color = '#515A5A') +
    facet_grid(cols = vars({{group}})) +
    #paletteer::scale_fill_paletteer_d("rcartocolor::Earth", direction = -1) +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal()
  
  return(list(plot = bar, data = data_counts.df))
  
}

```

#### Functions: defining duplexes from RNAplfold clusters

```{r}
get_duplex <- function(region.dt, cluster_number, cores = 4) {

  # Cluster 1 = 1-30 & 30-50
  # Cluster 2 = 8-36 & 36-63
  # Cluster 3 = 16-44 & 44-68
  
  if(cluster_number == 1) {
    
    c.L_start <- 1
    c.L_end <- 30
    c.R_start <- 31
    c.R_end <- 50
    
  } else if(cluster_number == 2) {
    
    c.L_start <- 8
    c.L_end <- 36
    c.R_start <- 37
    c.R_end <- 63    
    
  } else if(cluster_number == 3) {
    
    c.L_start <- 16
    c.L_end <- 44
    c.R_start <- 45
    c.R_end <- 68     
    
  } else {
    
    stop("cluster_number should be 1, 2, or 3")
    
  }
    
  c.dt <- region.dt[cluster == cluster_number]
  
  c.dt[strand == "+", 
        `:=` (L_start = xlink + c.L_start,
              L_end = xlink + c.L_end,
              R_start = xlink + c.R_start,
              R_end = xlink + c.R_end)]
  c.dt[strand == "-", 
        `:=` (L_end = xlink - c.L_start,
              L_start = xlink - c.L_end,
              R_end = xlink - c.R_start,
              R_start = xlink - c.R_end)] # start and end flipped for GRanges
  
  L.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = L_start, end = L_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  R.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = R_start, end = R_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  L.gr$seq <- as.character(getSeq(Hsapiens, L.gr))
  R.gr$seq <- as.character(getSeq(Hsapiens, R.gr))
  
  c.duplex.l <- mclapply(seq_along(L.gr), 
                         function(peak) analyse_structure(L.gr$name[peak], L.gr$seq[peak], R.gr$seq[peak]),
                         mc.cores = cores)
  
  c.duplex.dt <- rbindlist(c.duplex.l)
  c.duplex.dt <- merge(c.dt, c.duplex.dt, by = "name")
  c.duplex.dt$loop <- str_count(str_extract(c.duplex.dt$structure, "\\.*&\\.*"), "\\.")
  
  return(c.duplex.dt)
  
}

```

#### Functions: hybrids clustering

```{r}
resize_peaks <- function(bedfiles.list, left = 100, right = 100) {
  
  w <- left + right + 1  # width of interval: xl site + flanks
  
  grl <- GRangesList(lapply(bedfiles.list, import.bed))
  gr <- unlist(grl)
  gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")
  gr <- dropSeqlevels(gr, c("chrM", "chrY"), pruning.mode = "coarse")
  
  gr <- resize(gr, width = 1, fix = "start") # resize the peaks, start of peak = 1
  gr <- unique(gr)  # keep unique xl positions
  gr <- resize(resize(gr, width = right + 1, fix = "start"), width = w, fix = "end") # add +/- flanks
  gr$id <- paste0("ID", seq(1, length(gr)))
  
  return(gr)
  
}


merge_by_partial_string <- function(df1, df2) {
  
  df1$matchID = row.names(df1)
  df2$matchID = sapply(df2$gene_name, function(x) grep(x, df1$fasta_id)) # not very fast but ok
  
  df_merge = merge(df1, df2, by = "matchID")[-1]
  
  return(df_merge)
}

```

```{r}
get_paired_regions <- function(id, L_db, R_db) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  l_start <- l_brackets[1]
  l_end <- l_brackets[length(l_brackets)]
  
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  r_start <- r_brackets[1]
  r_end <- r_brackets[length(r_brackets)]
  
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  results.ls <- list(id = id, l_start = l_start, l_end = l_end, 
                     r_start=r_start, r_end=r_end)
  
  return(results.ls)
  
}

get_stem_loop_sequence <- function(hybrids.dt, genome.dt) {
  
  hybrids.dt[, gene_id := L_seqnames]
  setkey(genome.dt, gene_id)
  setkey(hybrids.dt, gene_id)
  
  seq.dt <- genome.dt[hybrids.dt]
  seq.dt[, `:=`(stem_loop_sequence, stringr::str_sub(sequence, start = L_start, end = R_end))]
  seq.dt[, `:=`(c("gene_id", "sequence"), NULL)]

  return(seq.dt)
}
```


#### Data

***
> Data directories

```{r}
data.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021"
plots.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/plots/figure_3"
ref.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/ref"
ref.dir2 <- "/Users/iosubi/Documents/projects/computational_hiCLIP/newest_datasets"
```

***
> Annotations

```{r warning=FALSE}
txdb <- paste0(ref.dir,"/gencode.v33.txdb.sqlite")
gencode.txdb <- AnnotationDbi::loadDb(txdb)
human.gtf <- paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz") # contains fasta_id used by Tosca
regions.gr <- import.gff2(paste0(ref.dir,"/regions.gtf.gz"))
genes.gr <- import.gff2(paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz"))
fa.dss <- readDNAStringSet((paste0(ref.dir2, "/GRCh38.gencode_v33.fa")))
```

***
> Probablility profiles

```{r}
prob.files <- list.files(paste0(data.dir,""), pattern = "_prob_profiles.tsv.gz", full.names = TRUE)
shuff.files <- prob.files[str_detect(prob.files, "shuffled")]
prob.files <- prob.files[!str_detect(prob.files, "shuffled")]
shuffled <- TRUE

prob.files
shuff.files
```

***
> Annotated peaks

```{r}
bed.files <- list.files(path = paste0(data.dir,""), pattern = "annot.bed.gz", full.names = TRUE)
stau1.bedfile <- bed.files[str_detect(bed.files, "stau1")]
print(stau1.bedfile)
```


# Fig 3 A: STAU1 peaks regional distribution

```{r}
peaks.gr <- import.bed(stau1.bedfile)
peaks.gr <- keepStandardChromosomes(peaks.gr, pruning.mode = "coarse")
peaks.gr <- dropSeqlevels(peaks.gr, c("chrM", "chrY"), pruning.mode = "coarse")

# Get region type
overlap <- findOverlaps(peaks.gr, regions.gr)
regions.gr$type <- as.character(regions.gr$type)

peaks.gr$type <- as.character(NA)
peaks.gr[queryHits(overlap)]$type <- regions.gr[subjectHits(overlap)]$type

peak_regions.df <- as.data.frame(peaks.gr)
peak_regions.df$id <- rownames(peak_regions.df)

peak_regions.df$type <- factor(peak_regions.df$type, levels = c("UTR5", "CDS", "intron", "UTR3", "ncRNA"))

region_colours <- c("ncRNA" = "#fbb04e", "intron" = "#bfbb60", "UTR5" = "#a2ceaa",
                    "rRNA" = "#4f6980", "UTR3" = "#f47942", "CDS" = "#638b66",
                    "tRNA" = "#849db1")

peak_regions.gg <- plot_stacked_barchart(peak_regions.df, column = type)$plot +
  guides(fill=guide_legend(title="Region")) +
  theme_minimal_grid() + 
  scale_fill_manual(values = region_colours) +
  theme(legend.position = "top") +
  scale_y_continuous(position = "right") +
  coord_flip()
  #  geom_text(data = peak_regions.df, aes(x = 0.65, y = 90, label = paste0("n = ", nrow(peak_regions.df))), inherit.aes = FALSE, size = 6) 
  
peak_regions.gg
# ggsave(paste0(plots.dir, "/stau1_peak_regions.pdf"), peak_regions.gg, width = 8, height = 3)
```


# Fig 3 B: STAU1 unpaired probability metaprofile

STAU1:

```{r}
stau1.prob.file <- prob.files[str_detect(prob.files, "stau1")]
stau1.shuff.file <- shuff.files[str_detect(prob.files, "stau1")]
prefix <- basename(stau1.prob.file)
prefix <- str_split(prefix, ".tsv")[[1]][1]
print(prefix)
```

```{r}
stau1.data.df <- get_metaprofile_dataframe(stau1.prob.file, stau1.shuff.file, shuffled = TRUE)
```

TDP-43:

```{r}
tardp.prob.file <- prob.files[str_detect(prob.files, "TARDP")]
tardp.shuff.file <- shuff.files[str_detect(prob.files, "TARDP")]

tardp.data.df <- get_metaprofile_dataframe(tardp.prob.file, tardp.shuff.file, shuffled = TRUE)
```

HuR:

```{r}
hur.prob.file <- prob.files[str_detect(prob.files, "ELAVL1")]
hur.shuff.file <- shuff.files[str_detect(prob.files, "ELAVL1")]
hur.data.df <- get_metaprofile_dataframe(hur.prob.file, hur.shuff.file, shuffled = TRUE)
```


```{r}
## Combine all RBPs
# Get number of peaks
stau1.counts <- unique(stau1.data.df$peaks_count)
hur.counts <- unique(hur.data.df$peaks_count)
tardp.counts <- unique(tardp.data.df$peaks_count)

hur.data.df$Experiment <- as.factor("HuR")
tardp.data.df$Experiment <- as.factor("TDP-43")
stau1.data.df$Experiment <- as.factor("STAU1")

merged.data.df <- rbind(stau1.data.df, hur.data.df, tardp.data.df)
data.df <- merged.data.df %>%
  dplyr::filter(!((Sample == "Control (shuffled)" & Experiment == "HuR") | (Sample == "Control (shuffled)" & Experiment == "TDP-43")))
data.df$Sample <- plyr::mapvalues(data.df$Sample, from=c("ELAVL1", "TARDP"), to=c("HUR", "TDP-43"))

merged.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
  scale_fill_manual(values=c('#222222','#E69F00', '#CD5C5C', '#A569BD')) +
  scale_color_manual(values=c('#222222','#E69F00', '#CD5C5C', '#A569BD')) +
  geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob), fill = Sample), alpha = 0.3, color = NA) +
  geom_line(aes(linetype = Sample)) +
  scale_linetype_manual(values=c("longdash", "solid","solid", "solid" )) +
  geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
  ylim(c(0.40, 0.60)) +
  xlab("Distance relative to the peak start (nt)") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme_minimal_grid() +
    ylab("Mean paired probability") +
    labs(linetype = "Sample") +
    # geom_text(aes(x = 55, y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 3) 
  geom_text(aes(x = -80, y = 0.43,label = paste0("n = ", hur.counts)), inherit.aes = FALSE, size = 4, color = "#E69F00") +
  geom_text(aes(x = -80, y = 0.415,label = paste0("n = ", stau1.counts)), inherit.aes = FALSE, size = 4, color = "#CD5C5C") +
  geom_text(aes(x = -80, y = 0.40,label = paste0("n = ", tardp.counts)), inherit.aes = FALSE, size = 4, color = "#A569BD") 

merged.gg <-
  append_layers(merged.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#31a1b3"), position = "bottom")
merged.gg <- merged.gg + theme(strip.background = element_blank())
merged.gg

# ggsave(paste0(plots.dir,"/RBPs_paired_metaprofile.pdf"), merged.gg, width = 6.5, height = 4, dpi = 300)
```

# Fig 3 C: STAU1 unpaired probability clusters

```{r}
# Load metaprofile dataframes (df output from get_structure_metaprofile.R)
stau1.prob.df <- fread(stau1.prob.file, skip = 1, data.table = FALSE)
stau1.prob.df <- column_to_rownames(stau1.prob.df, var = "V1")
colnames(stau1.prob.df) <- seq(1-(ncol(stau1.prob.df)+1)/2, (ncol(stau1.prob.df)-1)/2) # center column names on zero
stau1.prob.df <- drop_na(stau1.prob.df)

# ==========
# K-means clustering
# ==========
# Focus on the -50 to +75 nt relative to peak starts:
stau1.prob.df <- stau1.prob.df %>% dplyr::select("-50":"75")

# Convert unpaired probablity to paired probability
stau1.prob.df <- stau1.prob.df %>%
  mutate_if(is.numeric, convert_probability)

# Focus on the +10 to +75 nt relative to peak starts:
prob_downstream.df <- stau1.prob.df %>% dplyr::select("10":"75")
```

Find the optimal number of clusters

```{r}
set.seed(123)
silhouette.gg <- fviz_nbclust(prob_downstream.df, run_kmeans, method="silhouette")
silhouette.gg
# ggsave(paste0(plots.dir,"/silhouette_2k.pdf"), silhouette.gg, dpi = 300, width = 4, height = 4)
```

```{r}
n_clusters <- 2
```

Number of clusters for K-means clustering: `{r} n_clusters`

```{r  warning=FALSE, message=FALSE}
# K-means clustering - "euclidean" dist, 2 clusters
kmeans.df <- run_kmeans(prob_downstream.df, n_clusters)

# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(stau1.prob.df))
stau1.prob.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
stau1.prob.df$cluster_size <- kmeans.df$cluster_size

stau1.prob.df$cluster <- plyr::mapvalues(stau1.prob.df$cluster, from=c(1, 2), to=c(0, 1))
stau1.prob.df <- dplyr::arrange(stau1.prob.df, cluster)
stau1.prob.df$cluster <- factor(stau1.prob.df$cluster, levels = c(0, 1))

# Visualise the two clusters'means
col_pal <- brewer.pal(n_clusters, "Dark2")
clusters.gg <- plot_cluster_mean(stau1.prob.df, 51)
clusters.gg
```
Cluster 1 contains STAU1 peaks with higher paired probability. To further subset peaks based on the paired probability profiles, we will sub-cluster cluster 1.

```{r}
# Select cluster 1
cluster1.df <- stau1.prob.df %>%
  dplyr::filter(cluster == 1) %>%
  dplyr::select(-cluster, -cluster_size) 

# Focus on the region +10 to +75 nt relative to peak starts:
cluster1.df_downstream.df <- cluster1.df %>%
  dplyr::select("10":"75")

# Find the optimal number of clusters
set.seed(123)
silhouette_cl1.gg <- fviz_nbclust(cluster1.df_downstream.df, run_kmeans, method="silhouette")
silhouette_cl1.gg
# ggsave(paste0(plots.dir,"/silhouette_cluster1.pdf"), silhouette_cl1.gg, dpi = 300, width = 4, height = 4)
```

```{r}
# K-means clustering - "euclidean" dist, 3 clusters
kmeans.df <- run_kmeans(cluster1.df_downstream.df, 3)
# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(cluster1.df))
cluster1.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
cluster1.df$cluster_size <- kmeans.df$cluster_size

cluster1.df$cluster <- plyr::mapvalues(cluster1.df$cluster, from = c(3, 2, 1), to = c(3, 1, 2))
cluster1.df$cluster <- factor(cluster1.df$cluster, levels = c(1, 2, 3))

cluster1.df <- cluster1.df %>%
  dplyr::rename(.cluster = cluster)

# Select cluster 0 and join
cluster0.df <- stau1.prob.df %>%
  dplyr::filter(cluster == "0") %>%
  dplyr::rename(.cluster = cluster)

# Merge back cluster 0 and the subclusters of cluster 1
clusters.df <- rbind(cluster0.df, cluster1.df)
clusters.df$.cluster <- plyr::mapvalues(clusters.df$.cluster, from = c(3, 2, 1, 0), to = c(1, 2, 3, 0))
clusters.df$.cluster <- factor(clusters.df$.cluster, levels = c(0, 1, 2, 3))

stopifnot(nrow(stau1.prob.df) == nrow(clusters.df)) # Check same size as original prob df
```

```{r}
col_pal <- brewer.pal(4, "Dark2")
plot_cluster_heatmap(clusters.df, plot.title = prob.name, plot.name = paste0(plots.dir,"/",prefix,"_kmeans_minus50_paired_4clusters.png"))

# Export clusters data
clusters.df <- rownames_to_column(clusters.df, var = "id")
#fwrite(clusters.df, paste0(data.dir, "/", prefix,"_clusters.tsv.gz"), sep = "\t")
```

Metaprofiles for each cluster: 

```{r warning=FALSE, message=FALSE}
clusters.df <- clusters.df %>%
  dplyr::rename(cluster = .cluster)

col_pal <- brewer.pal(4, "Dark2")
clusters.gg <- plot_cluster_mean(clusters.df, 51) +
  scale_y_continuous(position = "right") +
  theme(strip.background = element_blank(), strip.text.x = element_blank())
clusters.gg <- append_layers(clusters.gg, annotate("rect", xmin = 10, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#31a1b3"), position = "bottom") +
  theme_minimal_grid()
clusters.gg
# ggsave(paste0(plots.dir,"/",prefix,"_cluster_profiles.pdf"), clusters.gg, width = 3.5, height = 10)
```

Clusters 1,2,3 contain structures with higher paired probability downstream the xlink site, suggesting the presence of putative stems.

### Define duplex arms


```{r}
dt <- as.data.table(clusters.df[clusters.df$cluster != 0,])

p.list <- lapply(1:3, function(i) {
  
  message(i)
  
  m <- colMeans(dt[cluster == i, .SD, .SDcols = !c("id", "cluster", "cluster_size")])
  lmin <- which(diff(sign(diff(m))) == 2) + 1 -51
  lmin <- lmin[lmin > 0]
  names(lmin) <- NULL
  print(lmin)
  
  p <- ggplot(data = data.frame(coord = as.integer(names(m)), score = m), aes(x = coord, y = score)) +
    geom_line() +
    geom_vline(xintercept = lmin, linetype = "dashed", colour = "blue") +
    theme_minimal_grid() +
    labs(x = "Coordinate",
         y = "Mean pairing probability",
         title = paste("Cluster", i))
  
  return(p)
  
})

# ggsave(plot_grid(plotlist = p.list, ncol = 1), filename = file.path(plots.dir, "sr_clusters_lmin.pdf"), width = 7, height = 10)
```


```{r}
# ==========
# Identify duplexes within arms
# ==========

peaks.dt <- as.data.table(import.bed("~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/stau1.10nt_10nt.peaks.annot_id.bed.gz"))
peaks.dt <- merge(peaks.dt, dt[, .(id, cluster)], by.x = "name", by.y = "id")
# setnames(peaks.dt, ".cluster", "cluster")
peaks.dt[, xlink := start + 101]

cluster.duplexes.l <- lapply(1:3, function(i) get_duplex(region.dt = peaks.dt,
                                                         cluster_number = i))

cluster.duplexes.dt <- rbindlist(cluster.duplexes.l)
# fwrite(cluster.duplexes.dt, "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_lmin_rnaduplex_structures.tsv.gz", sep = "\t")

# cluster.duplexes.dt <- fread("~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_lmin_rnaduplex_structures.tsv.gz")
```


Use peaks (IDs) in clusters 1, 2 and 3.

The short range duplexes were used using the local minima approach applied on each of clusters 1-3.

There are `r length(unique(cluster.duplexes.dt$name))` peaks in clusters 1,2,3.

```{r}
# cluster.duplexes.dt <- fread("~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_lmin_rnaduplex_structures.tsv.gz")
```


***
> Convert genomic coordinates to tx

#### Get genomic and tx coordinates for the resized peaks that have been used for RNAplfold

```{r}
# ==========
# Prepare gene IDs and coordinates
# ==========

# Load peaks data, resize exactly as for rnaplfold used to predict structures
peaks.gc.gr <- resize_peaks(stau1.bedfile, left = 100, right = 100)

# Save a record of the bed fie
peaks.id.gr <- peaks.gc.gr
peaks.id.gr$name <- peaks.id.gr$id
peaks.id.gr$id <- NULL

#export.bed(peaks.id.gr, paste0(data.dir, "/stau1.10nt_10nt.peaks.annot_id.bed.gz"))

# Add a new column containing gene ids by directly mapping the transcript ids
keys = peaks.gc.gr$name
mapped.ids <- AnnotationDbi::select(gencode.txdb, keys = keys, columns="GENEID", keytype="TXNAME")
peaks.gc.gr$gene_name <- mapped.ids$GENEID

# Add fasta_id from tx annotation used for Tosca as a new column

human.gr <- import.gff2(human.gtf)
human.gr <- keepStandardChromosomes(human.gr, pruning.mode = "coarse")
human.gr <- dropSeqlevels(human.gr, c("chrM", "chrY"), pruning.mode = "coarse")
human.df <- as.data.frame(human.gr)

genes.ls <- unique(peaks.gc.gr$gene_name) # create list of unique gene names from peak file to filter the human annotation

human.df <- human.df %>%
  filter(str_detect(fasta_id, paste(genes.ls, collapse = "|"))) # filter for gene names in the peak gr

human.df$row <- row.names(human.df)
human.df <- dplyr::rename(human.df, fasta_id_start = start, fasta_id_end = end)
human.df <- as.data.frame(human.df[,c("row", "fasta_id", "fasta_id_start", "fasta_id_end")])

peaks.gc.df <- as.data.frame(peaks.gc.gr)

peaks.gc.df <- merge_by_partial_string(human.df, peaks.gc.df)
peaks.gc.df <- peaks.gc.df %>%
  dplyr::select(-row)

# Add transcriptomic coordinates to the peaks file
peaks.df <- peaks.gc.df %>%
  mutate(tx_start = case_when((strand == "+") ~ start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - end + 1),
         tx_end = case_when((strand == "+") ~ end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - start + 1))

peaks.df <- dplyr::rename(peaks.df, tx_name = name)
```


```{r}
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  dplyr::mutate(L_genomic_start = L_start, L_genomic_end = L_end, R_genomic_start = R_start, R_genomic_end = R_end)

# Extract the start and end position of the stem-loop individually for each arm
arms.df <- cluster.duplexes.dt %>% 
  dplyr::select(name, seqnames, strand, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, mfe, structure)

# Merge df containing the peaks starts + 100 in genomic and transcriptomic coordinates to arms dataframe
arms.df <- as.data.frame(left_join(arms.df, peaks.df, by = c("name" = "id", "seqnames", "strand")))


# From the annotated peaks coordinates calculate tx coordinates of the  predicted stem
# ==========
# Obtain coordinates for each arm of the stem loop
# ==========

# Calculate L and R arms transcriptomic coordinates
arms.df <- arms.df %>%
  mutate(L_tx_start = case_when((strand == "+") ~ L_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - L_genomic_end + 1),
         L_tx_end = case_when((strand == "+") ~ L_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - L_genomic_start + 1),
         R_tx_start = case_when((strand == "+") ~ R_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~ fasta_id_end - R_genomic_end + 1),
         R_tx_end = case_when((strand == "+") ~ R_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~ fasta_id_end - R_genomic_start + 1))

# The peaks with gene IDs not present in fasta_ids of human annotation will have NAs instead of coordinates, so filtering them out
arms.df <- dplyr::filter(arms.df, !is.na(fasta_id))

# Check L and R arm coordinate widths are correct
stopifnot((arms.df$L_genomic_end - arms.df$L_genomic_start) == abs(arms.df$L_tx_end - arms.df$L_tx_start))
stopifnot((arms.df$R_genomic_end - arms.df$R_genomic_start) == abs(arms.df$R_tx_end - arms.df$R_tx_start))
```


```{r}
# Genomic (similar to tosca clusters table):
short_range.df <- data.frame(name = arms.df$name, count = arms.df$score, L_seqnames=arms.df$fasta_id,	
                                     L_start=arms.df$L_tx_start, L_end=arms.df$L_tx_end, L_strand="+", L_genomic_seqnames=arms.df$seqnames,
                                     L_genomic_start=arms.df$L_genomic_start, L_genomic_end= arms.df$L_genomic_end,
                                     L_genomic_strand=arms.df$strand, R_seqnames=arms.df$fasta_id, R_start=arms.df$R_tx_start, R_end=arms.df$R_tx_end,
                                     R_strand="+", R_genomic_seqnames=arms.df$seqnames,
                                     R_genomic_start=arms.df$R_genomic_start,  R_genomic_end= arms.df$R_genomic_end,
                                     R_genomic_strand =arms.df$strand, structure = arms.df$structure, mfe = arms.df$mfe)

stopifnot(abs(short_range.df$L_genomic_end - short_range.df$L_genomic_start) ==
            abs(short_range.df$L_end - short_range.df$L_start))
stopifnot(abs(short_range.df$R_genomic_end - short_range.df$R_genomic_start) ==
            abs(short_range.df$R_end - short_range.df$R_start))

#fwrite(short_range.df, "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_duplexes.tsv.gz", sep = "\t")
```


# Fig 3 C: Types of predicted duplexes at STAU1 binding sites 

#### Trim dot bracket structure to focus only on the paired regions and adjust genomic coordinates

```{r}
# Trim unpaired residues at the ends of left and right arms
# Separate L_db and R_db
short_range.df <- short_range.df %>%
  separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)

# Get positions of paired residues within structures of each arm
short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(paired_regions = list(get_paired_regions(id, L_db, R_db))) %>%
  mutate(L_duplex_start = paired_regions$l_start, 
         L_duplex_end = paired_regions$l_end - paired_regions$l_start + 1,
         R_duplex_start = paired_regions$r_start, 
         R_duplex_end = paired_regions$r_end - paired_regions$r_start + 1) %>%
  ungroup() %>%
  dplyr::select(-paired_regions)

short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(L_genomic_start = L_genomic_start + L_duplex_start - 1,
         L_genomic_end = L_genomic_start + L_duplex_end - 1, # this will use the updated L_genomic_start from the first mutate!
         R_genomic_start = R_genomic_start + R_duplex_start - 1,
         R_genomic_end = R_genomic_start + R_duplex_end - 1) %>%
  mutate(hairpin_loop = case_when(L_genomic_strand == "+" ~ R_genomic_start - L_genomic_end + 1 - 2,
                                  TRUE ~ L_genomic_start - R_genomic_end + 1 - 2)) %>%
  ungroup()

short_range.df <- dplyr::filter(short_range.df, hairpin_loop != 0)

# Also adjust tx coordinates
short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(L_start = L_start + L_duplex_start - 1, R_start = R_start + R_duplex_start - 1,
         L_end = L_start + L_duplex_end - 1, R_end = R_start + R_duplex_end - 1) %>%
  ungroup()
```

#### Duplex length

```{r}
# Calculate number of paired residues
short_range.df <- short_range.df %>%
  rowwise() %>%
  mutate(total_paired = str_count(L_db, "\\(")) %>%
  ungroup()

quantile(short_range.df$total_paired, c(.25, .50, .75, 1))
```


Separate duplexes on very short (less than 8 bp) and longer residues

```{r}
m_motif_structures <- list(nrow(short_range.df))
names(m_motif_structures) <- "M motif duplexes (clusters 1, 2, 3)"
m_motif_min8bp <- list(nrow(short_range.df[short_range.df$total_paired >= 8,]))
names(m_motif_min8bp) <-"M motif duplexes >= 8 bp"

m_motif_max9bp <- list(nrow(short_range.df) - nrow(short_range.df[short_range.df$total_paired >= 8,]))
names(m_motif_max9bp) <- "M motif duplexes < 8 bp"

no_m_motif <- list(nrow(stau1.prob.df) - nrow(short_range.df))
names(no_m_motif) <- "No M motif"
structure_types.ls <- c(no_m_motif, m_motif_max9bp, m_motif_min8bp)
types.df <- data.frame(structure_types = names(structure_types.ls), count = unlist(structure_types.ls, use.names=FALSE))

data_counts.df <- types.df %>%
  mutate(percentage = scales::percent(count / sum(count))) %>%
  mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
  mutate(pos = cumsum(percentage) - percentage/2)


types_colours <- c("No M motif" = "#216b77", "M motif duplexes >= 8 bp" = "#31a1b3", "M motif duplexes < 8 bp" = "#cbbba0")
pie.gg <- ggplot(data_counts.df, aes(x="", y=count, fill=reorder(structure_types, count))) +
    geom_bar(stat = "identity", width = 0.05, color="black") +
    coord_polar("y", start=0) +
    #scale_fill_brewer(palette = "Blues", direction = -1) +
    scale_fill_manual(values = types_colours) +
    ggrepel::geom_label_repel(aes(label = paste0(percentage,"%")), size = 3.5, show.legend = FALSE, position = position_stack(vjust = .5)) +
    ggrepel::geom_label_repel(aes(label = count), size = 2.5, show.legend = FALSE, position = position_stack(vjust = .3)) +
    guides(fill = guide_legend(title = "Structure type")) +
    theme_void() # remove background, grid, numeric labels

pie.gg
# ggsave(paste0(plots.dir,"/",prefix,"_structure_types.pdf"), pie.gg, width = 5, height = 4, dpi = 300)
```

```{r}
short_range.df <- short_range.df %>%
  mutate(structure_type = case_when(total_paired < 8 ~ "M motif duplexes < 8 bp",
                                    TRUE ~ "M motif duplexes >= 8 bp"))

```


# Fig 3 E: Hybridisation energy

```{r}
nrow(short_range.df)
```

```{r}
# Need to run 
mfe <- fread(paste0(data.dir, "/short_range_duplexes.mfe.tsv.gz")) # analyse_clusters_structure.R output ran on exported "short_range_duplexes.tsv.gz"

# stopifnot(nrow(short_range.df) == nrow(mfe))
mfe <- dplyr::filter(mfe, !(str_detect(L_sequence, "N") | str_detect(R_sequence, "N")))

short_range.df <- left_join(short_range.df, dplyr::select(mfe, L_sequence, R_sequence, name, mean_shuffled_mfe), by = "name")
```

```{r}
short_range.df$mean_shuffled_mfe <- as.numeric(short_range.df$mean_shuffled_mfe)
short_range.df$mfe <- as.numeric(short_range.df$mfe)
mfe.df <- pivot_longer(short_range.df, cols = c(mfe, mean_shuffled_mfe), names_to = "Sample", values_to = "MFE")

mfe.df <- mfe.df %>%
  mutate(Sample = case_when((Sample == "mfe") ~ "STAU1",
                            (Sample == "mean_shuffled_mfe") ~ "Shuffled control"))

mfe_median <- short_range.df %>%
  group_by(structure_type) %>%
  dplyr::summarize(Median = median(mfe, na.rm = TRUE))

```

```{r}
mfe_median
```


```{r}
bp_colours <- c("M motif duplexes >= 8 bp" = "#31a1b3", "M motif duplexes < 8 bp" = "#cbbba0")

mfe.dens.gg <- ggplot(mfe.df, aes(x = MFE, linetype = Sample, color = structure_type)) + 
  geom_density() + # color = c("#31a1b3", "#5ec3d3")
  # annotate("text", label = "p < 2.2e-16", x = -1, y = 1.7) +
  scale_linetype_manual(values=c("longdash", "solid")) +
  scale_color_manual(values = bp_colours) +
  theme(legend.position = "right") +
  theme_minimal_grid() + 
  ylab("Density") +
  xlab("Hybridisation energy (kcal/mol)") 
  # geom_vline(data=mfe_median, aes(xintercept=Median), linetype="dashed", color = "#31a1b3" )

mfe.dens.gg
# ggsave(paste0(plots.dir,"/","stau1_short_range_hybridisation_energy.pdf"), mfe.dens.gg, width = 7, height = 4)
```


```{r}
# Add stats:
stau1.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes >= 8 bp")$mfe
stau1.shuffled.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes >= 8 bp")$mean_shuffled_mfe
wilcox.test(stau1.mfe.ls, stau1.shuffled.mfe.ls)


mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes < 8 bp")$mfe
shuffled.mfe.ls <- dplyr::filter(short_range.df, structure_type == "M motif duplexes < 8 bp")$mean_shuffled_mfe
wilcox.test(mfe.ls, shuffled.mfe.ls)
```

# Fig 3 F: Hairpin loop size

```{r}
hairpin_median <- short_range.df %>%
  group_by(structure_type) %>%
  dplyr::summarize(Median = median(hairpin_loop, na.rm = TRUE))
hairpin_median
```

Focus on structures with more than 8 base pairs:

```{r}
short_range.df <- short_range.df %>%
  dplyr::filter(structure_type == "M motif duplexes >= 8 bp")

hairpin_median <- short_range.df %>%
  dplyr::summarize(Median = median(hairpin_loop, na.rm = TRUE))
hairpin_median

# Plot
hairpin.gg <- ggplot(short_range.df, aes(x = hairpin_loop)) + 
  #geom_histogram(bins = 45, color="black", fill = "#DEEBF7") +
  geom_density(color = "#31a1b3", bw = 0.1) +
  theme_minimal_grid() +
  geom_vline(data=hairpin_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  scale_x_log10() + annotation_logticks(sides = "b") + #breaks=c(3,5,7, 10,30))
  # ggtitle("Distribution of hairpin loop sizes") +
  xlab("Hairpin loop size (nt)") +
  ylab("Density")

hairpin.gg
# ggsave(paste0(plots.dir,"/", prefix,"_hairpin_lengths.pdf"), hairpin.gg, width = 4, height = 4)
```

```{r}
quantile(short_range.df$hairpin_loop, c(.25, .50, .75, 1))
```

Export data (this table will be used for creating the complete atlas)

```{r}
#fwrite(short_range.df, "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_duplexes_min8bp.tsv.gz", sep = "\t")
# Export bed file
short_range.dt <- data.table(short_range.df)
#export_genomic_bed(short_range.dt, paste0(data.dir, "/predicted_duplexes.bed"))
```

```{r}
nrow(short_range.df)
```


# Fig 3 G:  Breakdown of the atlas & Overlap with duplexes from STAU1 hybrid reads

#### Load experimental (linker and direct) duplexes

```{r}
data.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip"
stau1.dt <- fread(paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.collapsed_plus_nonhybrids.tsv.gz"))
stau1.hybrids.dt <- fread(paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.tsv.gz"))
```


How many duplexes are supported by multiple sources?

```{r}
clustered_short_range.df <- dplyr::filter(stau1.hybrids.dt, sample == "stau1_nonhybrid" & str_detect(cluster, "C"))
clustered_short_range.ls <- clustered_short_range.df$name

# For unclustered short-range structures, update clusters with ID
stau1.hybrids.dt <- stau1.hybrids.dt %>%
  mutate(cluster = case_when((sample == "stau1_nonhybrid" & !(name %in% clustered_short_range.ls)) ~ name,
                             TRUE ~ cluster))

# Filter only clustered hybrids and predicted duplexes
stau1.cluster.hybrids.df <- stau1.hybrids.dt %>%
  dplyr::filter(str_detect(cluster, "C") | str_detect(cluster, "ID"))

stau1.cluster.hybrids.df <- stau1.cluster.hybrids.df %>%
  rowwise() %>%
  mutate(id = case_when(cluster == name ~ cluster,
                        TRUE ~ paste(cluster, L_seqnames, R_seqnames, sep = "-"))) %>%
  ungroup()


nrow(stau1.cluster.hybrids.df) # number of hybrids that were assigned a cluster
stopifnot(length(unique(stau1.cluster.hybrids.df$id)) == nrow(stau1.dt))
```
```{r}
length(clustered_short_range.ls)
```

```{r}
stau1.cluster.hybrids_summary.df <- stau1.cluster.hybrids.df %>%
  group_by(id) %>%
  summarize(sample_set = paste(sort(unique(sample)), collapse=",")) %>%
  ungroup() 

stau1.samples.df <- stau1.cluster.hybrids_summary.df %>%
  dplyr::select(id, sample_set) %>%
  distinct()

stau1.dt <- left_join(stau1.dt, dplyr::select(stau1.samples.df, id, sample_set), by = c("name" = "id"))

# Get counts for each duplex dataset and combinations
source_counts.df <- stau1.dt %>%
  dplyr::select(name, sample_set) %>%
  distinct() %>%
  group_by(sample_set) %>%
  summarise(counts = n()) 

source_counts.df
```
```{r}
ht_colours <- c("Linker" = "#8175aa", "Direct" = "#6fb899", "Short-range" = "#31a1b3")

source.upset.input <- c("Linker" = source_counts.df[source_counts.df$sample_set == "stau1_linker",]$counts[1],
                        "Direct" = source_counts.df[source_counts.df$sample_set == "stau1_nolinker",]$counts[1],
                        "Short-range" = source_counts.df[source_counts.df$sample_set == "stau1_nonhybrid",]$counts[1],
                        "Linker&Direct" = source_counts.df[source_counts.df$sample_set == "stau1_linker,stau1_nolinker",]$counts[1],
                        "Linker&Short-range" = source_counts.df[source_counts.df$sample_set == "stau1_linker,stau1_nonhybrid",]$counts[1],
                        "Direct&Short-range" = source_counts.df[source_counts.df$sample_set == "stau1_nolinker,stau1_nonhybrid",]$counts[1],
                        "Linker&Direct&Short-range" = source_counts.df[source_counts.df$sample_set == "stau1_linker,stau1_nolinker,stau1_nonhybrid",]$counts[1])

pdf(file.path(plots.dir, "stau1_duplex_source_upset.pdf"), width = 7, height = 5)
upset(fromExpression(source.upset.input), order.by = "freq",
      mainbar.y.label = "Intersecting number of duplexes",
      sets.x.label = "Total number of duplexes",
      sets.bar.color=rev(ht_colours))
dev.off()
```



# Fig 3 H: Examples of short-range structures

```{r}
short_range_overlapped.df <- stau1.dt %>%
  dplyr::filter(str_detect(sample_set, ",stau1_nonhybrid"))

short_range_overlapped.cluster.ls <- unique(short_range_overlapped.df$name)

# Find these clusters in the hybrids table
short_range_overlapped.id.ls <- dplyr::filter(stau1.cluster.hybrids.df, id %in% short_range_overlapped.cluster.ls)$name

short_range_overlapped.id.ls <- short_range_overlapped.id.ls[str_detect(short_range_overlapped.id.ls, "ID")]
short_range_overlapped.id.ls
```

***
> Short-range structures that overlap with hybrid duplexes

```{r}
short_range.df %>% dplyr::filter(name %in% short_range_overlapped.id.ls & hairpin_loop <=14)
```

Candidates: ID13704, ID11685

```{r}
ex.ls <- dplyr::filter(stau1.cluster.hybrids.df, name %in% "ID11685")$id
ex.dt <- dplyr::filter(stau1.dt, name == ex.ls)
```

```{r}
ex.dt$L_seqnames
```

> Short-range structure within `r ex.dt$L_seqnames` that doesn't overlap with hybrid duplexes

```{r}
ex2.df <- short_range.df %>% dplyr::filter(!(name %in% short_range_overlapped.id.ls) & L_seqnames == ex.dt$L_seqnames)
ex2.df
```

```{r}
ex.dt
```


```{r}
fa.dt <- data.table(gene_id = names(fa.dss), sequence = as.character(fa.dss))

x <- get_stem_loop_sequence(as.data.table(short_range.df), fa.dt)
short_range2.df <- left_join(short_range.df, dplyr::select(x, name, stem_loop_sequence))

ex2.df <- short_range2.df %>% dplyr::filter(name == "ID11686" | name == "ID11685")
```

```{r}
short_range_exaples.dt <- as.data.table(rbind(ex.dt, ex2.df, fill = TRUE))
short_range_exaples.dt$q <- 0
short_range_exaples_bp.dt <- short_range_exaples.dt[, .(L_seqnames, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, q)]

# fwrite(short_range_exaples_bp.dt, sep = "\t", col.names = FALSE, file ="~/Dropbox (The Francis Crick)/comp_hiclip/short_range/sept_2021/short_range_examples.bp")

```


# Extras

```{r}
total_paired_median <- short_range.df %>%
  dplyr::summarize(Median = median(total_paired, na.rm = TRUE))
total_paired_median

# Plot
s.gg <- ggplot(short_range.df, aes(x=total_paired)) + 
  #geom_histogram(bins = 45, color="black", fill = "#DEEBF7") +
  geom_density(color = "#31a1b3", bw = 1.5) +
  theme_minimal_grid() +
  geom_vline(data=total_paired_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  #scale_x_log10() + annotation_logticks(sides = "b") + #breaks=c(3,5,7, 10,30))
  xlab("Paired residues") +
  ylab("Density")

s.gg
```







```{r}
# p = c(0, 0.25, 0.50, 0.75, 1)
#   
#   coord.dt <- cluster.duplexes.dt
#   coord.dt$q <- cut(cluster.duplexes.dt$score, 
#                     breaks = quantile(coord.dt$score, probs = p), 
#                     include.lowest = TRUE, 
#                     labels = 0:(length(p) - 2))
#   
#   cols <- tableau_seq_gradient_pal('Blue')(seq(0, 1, length = length(p) - 1))
#   cols.dt <- rbindlist(lapply(cols, function(x) data.table(paste(as.vector(col2rgb(x)), collapse = "\t"))))
#   cols.dt[, `:=` (colour = "color:",
#                   annotation = paste("Count quantile", 1:(length(p) - 1)))]
#   setcolorder(cols.dt, c("colour", "V1", "annotation"))
# 
# coord.dt <- as.data.table(coord.dt)
# bp.dt <- coord.dt[, .(seqnames, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, q)]
#   setorder(bp.dt, q)
#   
#   fwrite(cols.dt, sep = "\t", col.names = FALSE, quote = FALSE, file = "short_range.bp")
#   fwrite(bp.dt, sep = "\t", col.names = FALSE, file = "short_range.bp", append = TRUE)

```